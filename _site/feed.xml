<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://0.0.0.0:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="http://jekyllrb.com" version="3.3.0">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="zh" /><updated>2018-11-30T15:35:56+08:00</updated><id>http://0.0.0.0:4000//</id><title type="html">Ryan Wang’s blog</title><subtitle>Ryan Wang's Blog
</subtitle><author><name>Ryan Wang (Haide1977)</name><email>haide1977 AT gmail.com</email></author><entry><title type="html">MockingBot(墨刀)和 Axure RP的选择项</title><link href="http://0.0.0.0:4000/2018/10/21/choices_between_mockingbot_and_axure.html" rel="alternate" type="text/html" title="MockingBot(墨刀)和 Axure RP的选择项" /><published>2018-10-21T00:00:00+08:00</published><updated>2018-10-21T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2018/10/21/choices_between_mockingbot_and_axure</id><content type="html" xml:base="http://0.0.0.0:4000/2018/10/21/choices_between_mockingbot_and_axure.html">&lt;p&gt;因为偶然原因，“被迫”用MockingBot（墨刀）做了一回项目的产品原型。事情的最终走向是：费劲做完第一版原型后放弃，大家改用Axure重新制作了一版高保真原型。期间，再次体会了选择合适工具、才能有利于提高工作效率，准确传达设计意图，降低沟通成本。&lt;br /&gt;
【本文非研究文章，只谈直观感受。】
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;总体感受&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;如果你之前没有用原型工具甚至没有技术背景，可以用免费版本的墨刀先玩玩，找找感觉。&lt;/li&gt;
  &lt;li&gt;如果你要直观展现复杂的交互或者逻辑铺陈，不要犹豫，直奔Axure吧。&lt;/li&gt;
  &lt;li&gt;如果你想与非技术用户快速澄清几个需求点，用墨刀可能更省时间。你甚至可以和用户边讨论边改原型，直至方案定型。&lt;/li&gt;
  &lt;li&gt;如果你只是对现有成熟APP的功能点做迭代改进，且技术团队就是现有系统的维护者，那么，用墨刀很合适。&lt;/li&gt;
  &lt;li&gt;如果你要从头构建一个企业级的产品应用，放弃不切实际的幻想，老老实实用Axure吧。试图用墨刀呈现出Axure那样复杂度的高保真原型，你要花的工作量可能是翻倍再翻倍的。&lt;/li&gt;
  &lt;li&gt;如果协作是远程的，目前的墨刀的的点评系统，显然距离满足协作的需求还很远。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;对原型工具的理解&lt;/h2&gt;
&lt;p&gt;学习门槛低，肯定不是最首要的考虑因素。当然会有这样一部分需求的用户群。但是，用美图秀秀对比Photoshop的类比，来衬托原型工具的学习门槛低的价值，显然是不恰当的。毕竟，再简单的原型工具，也是生产力工具；而美图秀秀之类，天生是面向普通消费者的娱乐工具。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;原型的使命&lt;/h3&gt;
&lt;p&gt;通过制作原型，便于直观澄清语言表达不直观、理解容易有二义的需求，展现最终产物的关键面目。从而，达到降低成本和风险的目的。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;1.降低沟通成本。&lt;/h4&gt;
&lt;p&gt;一个好的原型结合其他材料，可以减少各方为弄清状况而进行沟通————“这个是什么意思？”、“那个是要来干嘛的？”、“我上次说的流程在哪里呢？“诸如此类，而更多的将沟通聚焦在“这是不是我想要的？”，“我觉得这里还需要进一步修改简化”等等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;沟通成本，当然也意味着时间成本和项目推进的节奏。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;2.降低研发成本。&lt;/h4&gt;
&lt;p&gt;变更和演进是不可避免的。但是因为各方理解的偏差，导致的变更和反复，应该尽量在前期予以消除。不同阶段修改的不同代价付出，大家都很清楚，此处不再赘述。&lt;/p&gt;

&lt;p&gt;所以，从项目管理的角度，好的原型对于项目范围、进度、成本、质量都可以产生积极影响，利于消除或者减弱相应的风险。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://postimg.cc/Wt90Wqn8&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/GhRzpkTW/20181021-PMfacts.png&quot; alt=&quot;项目管理的关键要素&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;无论是传统的项目管理，或是敏捷项目管理。这些关键要素无一例外。
原图出处：https://www.tapd.cn/forum/view/23641&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-5&quot;&gt;优秀原型工具的特质&lt;/h3&gt;

&lt;p&gt;既要降低项目成本和风险，又要在规划阶段保证产品的质量，同时还要兼顾项目推进，那么，对于所用的原型工具至少需要具备以下特性（对于20屏以下的简单小应用场景不在此讨论范畴）：&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;1.优秀的逻辑铺陈能力。&lt;/h4&gt;
&lt;p&gt;好的代码依靠代码本身和少量的注释，就能很好阅读。好的原型，应该也是如此。&lt;/p&gt;

&lt;p&gt;所谓优秀的逻辑铺陈能力，是指能通过原型本身呈现的逻辑线索，让用户或开发人员比较顺畅的走完整个原型，而不至于变成瞎子摸象，掉入功能细节的泥沼。&lt;/p&gt;

&lt;p&gt;反之，要依靠设计者再对着静态屏幕图片的逐一讲解，或者过多依赖原型之外的流程图和文档注释才能让使用者找到逻辑条线，显然会让原型的价值大打折扣。&lt;/p&gt;

&lt;p&gt;所以，首先工具要支持，然后是原型本身的“故事”要讲清楚。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;2.组件的复用能力。&lt;/h4&gt;
&lt;p&gt;原型主要用于早期沟通，所以快速、修改迭代是基本要求。&lt;br /&gt;
  就像糟糕的程序是把大同小异的代码不加提炼的反复复制一样；糟糕的原型制作同样如此。屏幕能够快速复制当然是必须的，但是组件间既有的逻辑关系是否应该优先保持稳定？ 如果所有的组件及其逻辑关系也是反复复制的，随着原型页面规模和复杂度的增加，修改的代价一定会翻着倍的提高。&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;3.运用上述两项能力的代价要合理。&lt;/h4&gt;
&lt;p&gt;毕竟，原型不是最终系统。如果制作和修订的成本（人力、时间等）过高，就适得其反了。&lt;br /&gt;
  最直接的，其实是系统要具备对元素及其关系的“ copy as link” 还是 “copy as duplicate”的可选项。&lt;/p&gt;

&lt;p&gt;另外，还是回到专业工具的一个话题。好的工具，就是当你高频使用的时候，会感觉越用越简单，越顺手。反之，差的设计是，偶然用一次觉得好像挺简单，但是随着量的累积，就会发现越来越繁琐。用拉线的方式来做链接，即是一例。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://postimg.cc/5jNpPVwB&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/Wp0K1pzH/20181021links.png&quot; alt=&quot;崩溃的拉线链接方式&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;电脑绣花&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;用了这么多年的工具，有一个比较直接的经验：所有一开始感觉用起来很简单的工具，最后发现都只能作为入门级玩具。原型工具，也差不多如此。玩具当然也有存在的价值，但工具的专业和业余的差别价值，无论在哪个行业都是毋庸讳言的道理了。&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;把视角稍微放大一点&lt;/h2&gt;

&lt;p&gt;如果把视角放大一些，思维再扩散一点，我前面大部分的表述可以被轻松推倒————因为假设条件未必成立。&lt;br /&gt;
&lt;strong&gt;都是中文惹的祸&lt;/strong&gt;。&lt;br /&gt;
从英文的角度，&lt;strong&gt;“原型”&lt;/strong&gt;其实本来就是几个不同的事情，代表了产品设计不同阶段的产物，主要的有：&lt;br /&gt;
&lt;strong&gt;wireframe ，mockups ，prototype&lt;/strong&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;wireframes&quot;&gt;第一阶段：wireframes【直译：线框图】。&lt;/h3&gt;
&lt;p&gt;这个阶段，各方关心的焦点是核心的业务功能和流程。至于布局、按钮大小／样式、logo在哪里等等细节，可以暂时不关心。wireframes 通过更加直观的方式，明确关键需求，作为需求规格说明的补充表述。&lt;/p&gt;

&lt;p&gt;这个阶段，拿个word，excel 做几个表格，其实也未尝不可。传说中，画在餐巾纸上，效果最佳。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://wireframe.cc/&quot;&gt;wireframe cc&lt;/a&gt;这个非常纯粹的的“原型”工具，可以了解一下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;mockups&quot;&gt;第二阶段：Mockups【直译：实物模型】&lt;/h3&gt;
&lt;p&gt;怎么界定模型？以日常所见的汽车模型，飞机模型为例：看上去挺逼真，轮子能转，门能开，甚至还能打开引擎盖、后备箱。或者，售楼处的看到的房子模型，沙盘上的模型挺漂亮，实际上，售楼处隔壁的茅草可能还挺长。大致如此。&lt;/p&gt;

&lt;p&gt;从APP或者软件产品的角度，原来干这个活的岗位，其实叫&lt;strong&gt;“美工”&lt;/strong&gt;，但是时代进步了，单单静态，孤立的图片或页面，对于表达产品的设想显然已经远远不够了。所以，我们需要把静态的元素和画面串起来，虽然不是真正的交互，但是可以把交互的意思表达出来。&lt;/p&gt;

&lt;p&gt;当然，本来&lt;strong&gt;美工&lt;/strong&gt;（或者类似的专业叫：工业设计）很擅长的东西————&lt;strong&gt;色彩，布局，字体，按钮&lt;/strong&gt;等等关键视觉元素，也可以涵盖在内了。&lt;/p&gt;

&lt;p&gt;很适合拿着这个酷炫的东西，去给领导或用户汇报，搞定关键的项目资源。但是，切记不要让他们自己动手玩，容易让他们陷入困扰，弄巧成拙。&lt;/p&gt;

&lt;p&gt;那些 &lt;strong&gt;mock&lt;/strong&gt;开头的“原型”工具，大多针对的是这个阶段。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://proto.io&quot;&gt;proto.io&lt;/a&gt; 也可以归于这一类。 
&lt;a href=&quot;https://www.mockplus.com/&quot;&gt;mockplus&lt;/a&gt;,倒是显得特性比较含糊了，对于工具产品来说，这未必是件好事情。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;prototype&quot;&gt;第三阶段：Prototype【直译：原型】&lt;/h3&gt;
&lt;p&gt;这个阶段，真正的意义上的&lt;strong&gt;原型&lt;/strong&gt;来了。 “原型车”这个词大家很耳熟吧？ 展会上经常看到。如果说模型车多数是放在桌上跑不了的，那原型概念车可是实实在在能跑起来的车子。&lt;/p&gt;

&lt;p&gt;所以，本文前两部分的讨论焦点，就是这个狭义的、高保真的、有逻辑铺陈和交互能力“原型” 。具备以下部分或全部特征的产品可能需要这样的原型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;业务复杂的&lt;strong&gt;To B 类项目&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;开发团队完全&lt;strong&gt;陌生的全新产品&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;项目涉及的&lt;strong&gt;协作方多&lt;/strong&gt;，对最终需求和目标容易产生理解偏差。&lt;/li&gt;
  &lt;li&gt;开发团队分散在不同地点、&lt;strong&gt;需要远程协作&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;最终用户的&lt;strong&gt;需求稳定性差&lt;/strong&gt;，存在需求蔓延和项目验收的风险。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时，如果是以下特征的项目，未必需要做这样的原型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;既有团队基于&lt;strong&gt;成熟产品的短期（如两周）的功能迭代&lt;/strong&gt;改进。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;产品处于种子期&lt;/strong&gt;，产品规模和研发团队规模都很微小。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;产品逻辑简单&lt;/strong&gt;，重点在 UI/UX的体验。&lt;/li&gt;
  &lt;li&gt;集中办公、采用敏捷迭代的&lt;strong&gt;开发小团队&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-10&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;“没有最好的工具，只有最适合的工具”&lt;/strong&gt;，这是一句正确而无用的鸡汤文。修饰词落脚在任何名词上，看上去都没什么问题。&lt;/p&gt;

&lt;p&gt;但是,任何选择都有机会成本。发现不合适需要成本，修正这个不恰当的选择，也需要代价。 所以，从不同视角，先弄清楚自己的工作需要，才有可能不被各种原型工具的产品宣传文晃晕。或者说，在不同场景下，灵活运用不同的工具来达到目标。本文从场景、团队、产品形态和研发特征等角度来看的那些选择项，算是提供一种参考模板吧。&lt;/p&gt;

&lt;p&gt;用一段RAP+绕口令来结束本文：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mockups是Mockups ,&lt;br /&gt;
Prototype是Prototype; &lt;br /&gt;
此原型非彼原型，&lt;br /&gt;
不要把彼原型当成此原型。&lt;br /&gt;
谁用Mockups工具做Prototype，&lt;br /&gt;
谁就成了“棒～槌”。 &lt;br /&gt;
别把Prototype做成了Mockups，&lt;br /&gt;
那你就成了Mock PM.。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;section-11&quot;&gt;&lt;strong&gt;更多参考&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://uiux.blog/prototyping-tools-review-is-axure-rp-the-best-tool-for-prototyping-cefbb562d01c&quot;&gt;Prototyping Tools Review: Is Axure RP the Best Tool for Prototyping &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.mindinventory.com/blog/the-difference-between-wireframe-mockup-and-prototype/&quot;&gt;The Difference Between Wireframe, Mockup and Prototype&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;*&lt;end&gt;*&lt;/end&gt;&lt;/p&gt;</content><author><name>Ryan Wang (Haide1977)</name><email>haide1977 AT gmail.com</email></author><category term="工具" /><category term="产品" /><category term="研发" /><summary type="html">因为偶然原因，“被迫”用MockingBot（墨刀）做了一回项目的产品原型。事情的最终走向是：费劲做完第一版原型后放弃，大家改用Axure重新制作了一版高保真原型。期间，再次体会了选择合适工具、才能有利于提高工作效率，准确传达设计意图，降低沟通成本。
【本文非研究文章，只谈直观感受。】</summary></entry><entry><title type="html">能源区块链项目采样与思考</title><link href="http://0.0.0.0:4000/2017/12/27/Energy_Blockchain_Cases_and_Thinking.html" rel="alternate" type="text/html" title="能源区块链项目采样与思考" /><published>2017-12-27T00:00:00+08:00</published><updated>2017-12-27T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2017/12/27/Energy_Blockchain_Cases_and_Thinking</id><content type="html" xml:base="http://0.0.0.0:4000/2017/12/27/Energy_Blockchain_Cases_and_Thinking.html">&lt;p&gt;针对区块链和数字币在能源领域的国外的应用案例，做了一个管窥式的快速采样。以便对这一领域方向，有一些自己直观的判断。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;jouliette&quot;&gt;▸ 荷兰 Jouliette(焦耳币)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://postimg.cc/xkqqHyS2&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/9fY96J8r/20171227topic.png&quot; alt=&quot;焦耳币社区&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://postimg.cc/tsBYYvwk&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/mrsMp0Sv/20171227jwallet.png&quot; alt=&quot;焦耳币／钱包&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;图片来自 Jouliette.net&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The Jouliette &lt;strong&gt;焦耳币&lt;/strong&gt;  &lt;br /&gt;
荷兰国内首创 。名字源自能量的计量单位：焦耳。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;§ 发起组织&lt;/h4&gt;
&lt;p&gt;总部在阿姆斯特丹的智慧能源公司Spectral 和荷兰分布式系统运营者联盟（Dutch distribution system operator Alliander）。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;§ 项目目标&lt;/h4&gt;
&lt;p&gt;通过这一新的电子货币——焦耳币，帮助个人和社区更方便的管理和分享本地产出的可再生能源。
希望成为利用区块链技术的能力来产生更大的社会价值的一个示范。以100%的可再生的能源为基础，来支持“自底向上”的，更加分布式的，强壮的，透明的经济方式转换。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;§ 运营情况&lt;/h4&gt;

&lt;p&gt;2017-9-15，在阿姆斯特丹的下属的 De Ceuvel 创新实验社区发行。利用 “焦耳”币，社区居民可以安全的、点对点的直接利用他们的虚拟货币钱包进行交易。 
这个经济生态系统在De Ceuvel可行的基础是：该地区是典型的，基于智能电网的私人可再生能源区。没有任何对太阳能光伏生产的可再生能源交易的限制，也规避了现存的市场障碍（market barriers）。&lt;/p&gt;

&lt;p&gt;通过“焦耳”币平台，社区可以方便的管理其“微经济” （micro-economy ）。不同于存粹的投机货币（speculative currencies），焦耳币有物理能源的生产作为支撑——或者说 &lt;strong&gt;现实映射&lt;/strong&gt; 。&lt;/p&gt;

&lt;p&gt;社区在探索的进一步的焦耳币应用包括，在当地咖啡馆消费，本地时间银行系统（时间交换），以及与其他跨社区服务的整合，如共享汽车（car-sharing ）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考：&lt;br /&gt;
&lt;a href=&quot;http://deceuvel.nl/en/&quot;&gt;De Ceuvel 社区&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://timebanks.org/what-is-timebanking/&quot;&gt; 本地时间银行系统(local time-banking system )&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;除了点对点的交易，焦耳币平台还提供实时的社区能量流地图，高分辨率的数据可视化以及基于机器学习的预测系统，帮助用户更好洞察自己的实时能量使用、能量生产和消费规划的情况。&lt;/p&gt;

&lt;p&gt;Pallas Agterberg, 联盟的战略总监（strategy director at Alliander ）：
 “ 总体来说，当社会向可再生能源系统过渡的路上，需要一个大的解决方案。较之于（转换不易度量，昂贵和远离大众的）二氧化碳的地下深埋和远海岸的风场等方式，我们希望有一种成本适中，甚至降低成本的方式来加速向可再生利用的转换。”&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考：&lt;br /&gt;
Pallas Agterberg, strategy director at Alliander:&lt;a href=&quot;https://www.linkedin.com/in/pallas-agterberg-9564a95/&quot;&gt;linkedin资料&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-3&quot;&gt;§ 平台功能特点&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Community Map 社区地图    展现实时的社区微网的电流（包括生产和消费），同时具体到每个建筑情况，也可以展现热泵的消耗情况。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;预测  &lt;br /&gt;
预测在微网内，太阳能光伏的能量生产。借助Icarus 系统（荷兰可再生运营联盟研发的：通过机器学习等算法、气候预测（包括云的移动）、能实时太阳能板任何给定区域的太阳能生产）。
能实现实时的预、实对比。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;焦耳币  &lt;br /&gt;
只在社区内部流通。用户客户通过数字币浏览器来验证和查看自己的币，通过平台进行币的赠送。支持可配置功能实现自动交易。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考：  &lt;br /&gt;
- &lt;a href=&quot;https://dashboard.icarus.energy/&quot;&gt;Icarus 系统&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;http://www.renewableenergyworld.com/articles/2017/09/blockchain-token-to-share-renewable-energy-unveiled.html&quot;&gt;blockchain-token-to-share-renewable-energy-unveiled&lt;/a&gt;     &lt;br /&gt;
- &lt;a href=&quot;https://jouliette.net/blockchain.html&quot;&gt;jouliette.net &lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-4&quot;&gt;▸纽约 布鲁克林 社区微网（与区块链 ）&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://postimg.cc/tZxTvqTv&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/TwkDwhXx/20171227bmg.jpg&quot; alt=&quot;布鲁克林微网&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;图片来自brooklynmicrogrid@facebook&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;布鲁克林微网（简称 BMG），2015年开始建设。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;§ 发起组织&lt;/h4&gt;
&lt;p&gt;LO3 energy （ https://lo3energy.com/ ）， 西门子下属的风投 Next47投资。&lt;br /&gt;
Braemar energy ventures 和 Centrica 在2017年10月跟投（据称，超过10亿英镑）。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;§ 项目目标&lt;/h4&gt;
&lt;p&gt;安装和未安装光伏系统（photovoltaic（PV） systems）的社区邻居，通过一个区块链平台，进行光伏太阳能电能的相互买卖和交易记账。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;§ 运营情况&lt;/h4&gt;
&lt;p&gt;过去两年，LO3 Energy 团队优化了在复杂智能计量技术基础上的区块链的安全和延迟问题，来确保真实用户使用时的强壮和稳定性。 &lt;br /&gt;
交易的思路参照了美国的绿证制度。只不过用户购买的不再是虚拟的能源供应者，而是社区内邻居生产的可再生能源。&lt;/p&gt;

&lt;p&gt;截止2017年初，系统包括了50栋褐石别墅、一些公寓房、学校、还有一个加气站，一个消防站和一些工厂建筑。预计到2018年，将会有1000个参与者。同时计划安装储能站和更多的光伏系统。西门子数字电网部门提供包括微网管理系统在内的支撑。&lt;/p&gt;

&lt;p&gt;为了确保成功，区块链平台和微网需要一套监管制度框架。在纽约州，“改革能源愿景（REV，“Reforming the Energy Vision”）”的战略规划，提供了这样的框架。&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;§ 平台功能特点&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;强调社区文化和社区内用户间的互动&lt;/li&gt;
  &lt;li&gt;整体架构规划比较完整。&lt;/li&gt;
  &lt;li&gt;有西门子完整的能源层智能设备和解决方案的支撑。
&lt;a href=&quot;https://postimg.cc/bGMrRDz2&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/4d4csVqw/20171227bmg-Layers.png&quot; alt=&quot;BMG技术架构整理&quot; /&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;BMG技术架构整理&lt;br /&gt;
  -TAG-e :  能量计量，计算，通信一体的混合终端设备。 &lt;br /&gt;
  -Exergy 体系，整个BMG中区块链基础和市场。（产生Exergy 币，并提供交易能力）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考:  &lt;br /&gt;
  -&lt;a href=&quot;https://lo3energy.com/&quot;&gt;LO3 energy&lt;/a&gt;&lt;br /&gt;
  -&lt;a href=&quot;http://brooklynmicrogrid.com/&quot;&gt;brooklynmicrogrid.com&lt;/a&gt;&lt;br /&gt;
  -&lt;a href=&quot;https://futurism.com/blockchain-and-renewable-energy-are-utterly-disrupting-society-as-we-know-it/&quot;&gt;blockchain-and-renewable-energy-are-utterly-disrupting-society-as-we-know-it&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;powr-token&quot;&gt;▸澳州（POWR token币）&lt;/h2&gt;

&lt;h4 id=&quot;section-9&quot;&gt;§ 发起组织&lt;/h4&gt;
&lt;p&gt;Power Ledger (https://web.powerledger.io/ ）。 &lt;br /&gt;
2017-10-06，通过 ICO，完成了超过3.4亿澳元（约2.4亿美元的），获得来自15000名支持者的筹资。
而后，在72小时内，平台成交了价值1.7亿美元的POWR token （POWR币）。
环境学家保罗·多诺万（Paul Donovan） 投资了Power Ledger（能量账本）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考：&lt;br /&gt;
&lt;a href=&quot;http://www.abc.net.au/news/2017-10-11/blockchain-technology-fuels-peer-to-peer-energy-trading-start-up/9035616&quot;&gt;区块链技术助推点对点能量交易的创业公司 &lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-10&quot;&gt;§ 运营情况&lt;/h4&gt;
&lt;p&gt;POWR币可与以太币，SPARKz【备注：SPARKz是它系统内的能量计量单位】等进行交易。&lt;/p&gt;

&lt;p&gt;在目前的项目中，也可以根据用户的需求以不同的方式进行，交易单位是自行生产的太阳能或自行存储的电池能量。&lt;/p&gt;

&lt;p&gt;Power Ledger (能量账本)支持真实世界的能源销售商。2016年秋天，在西澳，就行了15个家庭的试验。2016年末，在新西兰，进行了500个现场项目设备的试验。2017年夏天，首次在Fremantle（注：弗里曼特尔,西澳）居民区进行商业运行，成为澳洲第一个 “不通过电力零售商，便利化电力计量和管理定居点的电力交易” 的公司。&lt;/p&gt;

&lt;p&gt;与Indra Australia（英德拉公司 https://www.indracompany.com/en/indra ）达成了技术整合协议；与西澳的电力供应商启动了在平台上进行充电交易的计划。&lt;/p&gt;

&lt;p&gt;Power Ledger(能量账本) 是较好的几个能源领域的商业模式之一：他们积极与公用事业的公司合作，并且试图找出在现有监管体系下进行运营的空间。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考：&lt;br /&gt;
&lt;a href=&quot;https://www.greentechmedia.com/articles/read/power-ledger-blockchain-energy-trading-startup-raises-17-cryptocurrency&quot;&gt;Blockchain Energy Trading Startup Power Ledger Raises $17M in Cryptocurrency&lt;/a&gt;     ，2017-09-06  （后续有更新）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-11&quot;&gt;§ 平台功能特点&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;支持点对点的售电（光伏生产商）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;引入全新的Sparkz单位，作为能量的数字表示
  系统会计量能量的生产和消费。把两部分信息记录到区块链，并且利用 Sparkz这个计量单位来记录能量在交易者之间的转移。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;平台电子钱包间的 Sparkz的转移（几乎和能量生产、交易同步），用户还可以把Sparkz转换为澳元。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-12&quot;&gt;▸其它案例&lt;/h2&gt;

&lt;h4 id=&quot;conjoule&quot;&gt;§ 东电投资德国点对点交易商Conjoule&lt;/h4&gt;
&lt;p&gt;东京电力公司向德国知名点对点交易商 &lt;a href=&quot;http://conjoule.de&quot;&gt; Conjoule&lt;/a&gt;投资三百万欧元，作为与德国能源公司 &lt;a href=&quot;http://innogy.com/&quot;&gt;Innogy SE&lt;/a&gt;  共同向其A轮投资四百五十万欧元的一部分。&lt;/p&gt;

&lt;h4 id=&quot;section-13&quot;&gt;§ 另外一些初创公司&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.joindrift.com/get-estimate&quot;&gt;Drift &lt;/a&gt;
 为用户寻找绿色、省钱的能源方案，利用区块链来完成点对点交易。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gridsingularity.com&quot;&gt;Grid Singularity&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.electron.org.uk&quot;&gt;Electron &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://emotorwerks.com&quot;&gt;eMotorWerks&lt;/a&gt;加州的共享家庭充电桩平台利用区块链技术来提升交易的效率和便捷度。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考：&lt;br /&gt;
&lt;a href=&quot;https://www.greentechmedia.com/articles/read/leading-energy-blockchain-firms&quot;&gt;全球领先的15家能量区块链公司&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-14&quot;&gt;▸观点&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;封闭体系内运行的能源币，接近“积分”模式，可以简化问题复杂度（如“焦耳”币）；开放可交换的能源币（如Sparkz），对技术、政策、商业模式的挑战度更大，面临现有监管和市场的障碍也更多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;国外的创业项目多数从用户端视角出发，按照完全市场化的模式运作。与国内目前绝大所数能源互联网的示范项目存在本质上的差异。从传统互联网的发展经验来说，是“得用户者得天下”。我们会不会“起个大早，赶个晚集”，值得关注。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;国外的落地项目，同样会面临市场、法律和监管的障碍，结合实际，寻找合适的切入和成长空间是商业模式能成功的关键。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;能得到投资者青睐的能源区块链项目，一定是将区块链价值和能源价值形成现实映射的————即便映射和价值闭环未必完整。同时，也必须是助推绿色、环保、高效、可持续的可再生能源运用的“故事”。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择既有的、基础设施条件较成熟的可再生能源微网区域，是起步项目实现区块链与之现实映射的捷径。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;技术架构中要解决两个关键点：在哪里算和怎么算。 哪里算————可能好的方案是在用能和产能的最终端实现计量、计算、通信的一体化；怎么算————要解决如何对能量生产（可能包括传输、存储）的贡献价值的统一、客观、合理的计算。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;作为起步项目，可以考虑把业务场景问题简化，能把简单的场景做到可持续扩展，同样会产生巨大的价值。然后再来考量是否需要把复杂场景进一步纳入现有体系中。本文中的涉及的部分项目，可作参考。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;*&lt;end&gt;*&lt;/end&gt;&lt;/p&gt;</content><author><name>Ryan Wang (Haide1977)</name><email>haide1977 AT gmail.com</email></author><category term="架构" /><category term="能源互联网" /><category term="区块链" /><summary type="html">针对区块链和数字币在能源领域的国外的应用案例，做了一个管窥式的快速采样。以便对这一领域方向，有一些自己直观的判断。</summary></entry><entry><title type="html">场景式的研究工具箱杂论</title><link href="http://0.0.0.0:4000/2017/12/16/research_resources.html" rel="alternate" type="text/html" title="场景式的研究工具箱杂论" /><published>2017-12-16T00:00:00+08:00</published><updated>2017-12-16T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2017/12/16/research_resources</id><content type="html" xml:base="http://0.0.0.0:4000/2017/12/16/research_resources.html">&lt;p&gt;最近开始接触全新的目标问题域，成果暂时还是空白。在梳理研究思路的同时，顺便整理了一下辅助工具和网站。&lt;/p&gt;

&lt;p&gt;欲善其事，先利其器。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;▸先给研究起个好代号吧&lt;/h2&gt;
&lt;p&gt;给关键技术、平台或者项目起个好代号，利于沟通。名正才能言顺。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://acronymify.com/&quot;&gt;acronymify.com&lt;/a&gt;&lt;br /&gt;
提供一段关键词，网站会自动创造一个系列候选缩写，选上一个满意的。 
&lt;a href=&quot;https://postimg.cc/SnJgv36Y&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/nh1NCtM2/20171216acronymify.png&quot; alt=&quot;acronymify.com&quot; /&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;▸利用研究管理平台&lt;/h2&gt;
&lt;p&gt;研究平台，让研究更有条理。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.mendeley.com/&quot;&gt;mendeley.com&lt;/a&gt;  &lt;br /&gt;
免费的研究管理平台，包括文献索引管理和学术社交网络（号称600万学术研究用户）等。 &lt;br /&gt;
涵盖了知名的商业工具EndNote的部分功能。提供支持Windows、MacOS操作系统的桌面程序以及ios、android的app。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.researchgate.net&quot;&gt;ResearchGate.net&lt;/a&gt;&lt;br /&gt;
更专业的平台,注册账号要通过审核，需要你提供材料【推荐人／过去发表的研究成果】来证明自己不是打酱油的，而是真的在从事研究工作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://scholar.google.com&quot;&gt;scholar.google.com&lt;/a&gt;   &lt;br /&gt;
google学术，通过收藏检索结果，快速建立自己的文献库。加标签、额外内容编辑关联以及批量下载索引都是很实用的功能。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;▸先看看外面世界的状况&lt;/h2&gt;
&lt;p&gt;先了解问题域研究的发展趋势和脉络，既可避免一头扎进细节里，又可避免重复造轮子。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://trend.cnki.net/&quot;&gt;trend.cnki.net&lt;/a&gt;     &lt;br /&gt;
cnki上的专业名词的翻译助手和名词定义，也是不错的资源。&lt;br /&gt;
&lt;a href=&quot;https://postimg.cc/bs66Lptj&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/HkmfYLWj/20171216cnki.png&quot; alt=&quot;cnki上的趋势曲线&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://wanfangdata.com.cn&quot;&gt;万方&lt;/a&gt; &lt;br /&gt;
万方支持&lt;strong&gt;导出&lt;/strong&gt;功能和&lt;strong&gt;自动参考文献格式&lt;/strong&gt;生成，可以顺便搜集，以便未来下载和引用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://postimg.cc/Cn78hMgM&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/Bt9BCt7F/20171216wanfang.png&quot; alt=&quot;万方上的研究趋势曲线&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://postimg.cc/9RGTktg7&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/DZNg8xqB/20171216wanfang3.png&quot; alt=&quot;标准参考引用格式生成&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.semanticscholar.org/&quot;&gt;semanticscholar.org&lt;/a&gt;    &lt;br /&gt;
将作者信息与知名的社交媒体做了关联。对引用做了影响力的自动评估。检索能力强。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;▸切入正题，开始看文献。&lt;/h2&gt;
&lt;p&gt;除了大学、公共图书馆的一些免费资源的下载入口，对于一般的中文期刊文献，如果不能从scholar.google.com 上找到全文。那么只能考虑购买或者写邮件找作者索要了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;英文文献的全文传送门&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;传说中的 &lt;strong&gt;sci-hub&lt;/strong&gt;，访问方式需要不停的变换，这里不推荐了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.semanticscholar.org/&quot;&gt;semanticscholar.org&lt;/a&gt;  【前文已经提到】&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gen.lib.rus.ec/&quot;&gt;library genesis&lt;/a&gt;  &lt;br /&gt;
除了全文下载，也有检索关键词的文献趋势查询。&lt;br /&gt;
&lt;a href=&quot;https://postimg.cc/jLqgzLCX&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/vHfJwnsp/20171216librarygenesis.png&quot; alt=&quot;library genesis&quot; /&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;专业技术书籍下载&lt;/strong&gt; &lt;br /&gt;
- &lt;a href=&quot;http://en.booksee.org&quot;&gt;booksee.org&lt;/a&gt; 及 &lt;a href=&quot;http://booksc.org&quot;&gt;booksc.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一般电子书、普通工具类技术文档下载地址实在太多了…最大的问题是看不过来。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;▸数学计算与公式&lt;/h2&gt;
&lt;p&gt;没有一堆眼花缭乱的公式，你都不好意思出门说自己研究有深度，理论有高度。
有了辅助工具网站，可以节省不少复习数学的时间。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.numberempire.com/&quot;&gt;numberempire.com&lt;/a&gt;&lt;br /&gt;
各类数值计算器和编辑器，包括LaTex的编辑器。 &lt;br /&gt;
&lt;a href=&quot;https://postimg.cc/BtB7LxZb&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/ZY1GQc18/20171216numberempire.png&quot; alt=&quot;numberempire函数大全&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.derivative-calculator.net/&quot;&gt;derivative-calculator.net&lt;/a&gt;  &lt;br /&gt;
导数计算 ，包括高阶导数的求导。有步骤及图形化的结果展示和导出。&lt;br /&gt;
&lt;a href=&quot;https://postimg.cc/XX4QbpKb&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/xjb7Lmcc/20171216derivative.png&quot; alt=&quot;可视化求导&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;支持导出LaTex表达式。 &lt;br /&gt;
&lt;a href=&quot;https://postimg.cc/njY2mJJg&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/26gKPkXk/20171216derivative2.png&quot; alt=&quot;导出LaTex&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;▸数据源&lt;/h2&gt;
&lt;p&gt;这个主题很大。不同的研究方向都会有一套自己的实验数据源。比如，做AI人脸识别，需要人脸库。
做流行病预测研究，需要多个维度的疾病登记数据；做智能投顾，需要证券市场的交易数据等。&lt;/p&gt;

&lt;p&gt;所幸，作为研究来说，网络上可以找到的免费数据源基本足够支撑。&lt;/p&gt;

&lt;p&gt;这里只是随便罗列几个例子：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://data.gov/&quot;&gt;data.gov&lt;/a&gt;  &lt;br /&gt;
美国政府数据开放平台。政府数据开放的一个好榜样。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://data.stats.gov.cn/&quot;&gt;data.stats.gov.cn&lt;/a&gt;&lt;br /&gt;
国家统计局的官方网站数据源【最小时间跨度为月度】&lt;br /&gt;
&lt;a href=&quot;https://postimg.cc/D4ns3JRY&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/NFrxTRDY/20171216nationalstatistics.png&quot; alt=&quot;国家统计局数据源&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.ecmwf.int/&quot;&gt;ecmwf.int&lt;/a&gt;    &lt;br /&gt;
欧洲中期气候预报&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;不展开了…&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;▸学术写作的语言辅助&lt;/h2&gt;
&lt;p&gt;要开始写东西，英文不熟练怎么办？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;词语搭配查询   &lt;br /&gt;
&lt;a href=&quot;http://linggle.com/&quot;&gt;linggle.com&lt;/a&gt; 和 &lt;a href=&quot;http://www.netspeak.org/&quot;&gt;netspeak.org&lt;/a&gt;    &lt;br /&gt;
&lt;a href=&quot;https://postimg.cc/bGn3znFz&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/N0JVk76r/20171216lingglenetspeak.png&quot; alt=&quot;linggle &amp;amp; netspeak &quot; /&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;【其实，“有道”字典里的例句功能，也是非常好的参考。】&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在线学术写作  &lt;br /&gt;
&lt;a href=&quot;https://www.overleaf.com/&quot;&gt;overleaf.com&lt;/a&gt;  丰富的排版模板，所见即所得的在线编辑，方便的文档生成和分享。&lt;br /&gt;
&lt;a href=&quot;https://postimg.cc/S2pVjKwc&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/W3dyWF8Y/20171216overleaf.png&quot; alt=&quot;overleaf &quot; /&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;终于折腾出点头绪了&lt;/strong&gt;&lt;br /&gt;
不要着急着高兴，苦难才刚刚开始…&lt;/p&gt;</content><author><name>Ryan Wang (Haide1977)</name><email>haide1977 AT gmail.com</email></author><category term="方法杂论" /><category term="工具箱" /><summary type="html">最近开始接触全新的目标问题域，成果暂时还是空白。在梳理研究思路的同时，顺便整理了一下辅助工具和网站。

欲善其事，先利其器。</summary></entry><entry><title type="html">Road_to_https 既有系统的https的改造</title><link href="http://0.0.0.0:4000/2016/12/09/Road_to_https.html" rel="alternate" type="text/html" title="Road_to_https 既有系统的https的改造" /><published>2016-12-09T00:00:00+08:00</published><updated>2016-12-09T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2016/12/09/Road_to_https</id><content type="html" xml:base="http://0.0.0.0:4000/2016/12/09/Road_to_https.html">&lt;h3 id=&quot;section&quot;&gt;研究目标&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;整理 https 相关的基本知识；&lt;/li&gt;
  &lt;li&gt;梳理现存网站全面转向 https 的相关行动事项；&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;section-1&quot;&gt;主要内容&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;相关名词和基本知识；&lt;/li&gt;
  &lt;li&gt;简明的行动项清单；&lt;/li&gt;
  &lt;li&gt;重点技术项的细化阐述，包括证书，性能改善等；&lt;/li&gt;
  &lt;li&gt;一些行动建议；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;引子&lt;/h2&gt;
&lt;p&gt;如果你对这个课题还没有什么&lt;strong&gt;感性认识&lt;/strong&gt;，为了避免一开始就掉入过于枯燥、抽象的技术名词的泥沼，建议先试试以下两个事情：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用chrome 或 Firefox 桌面（非手机端）浏览器，打开下面几个网站：&lt;br /&gt;
第一组：&lt;a href=&quot;http://github.com&quot;&gt;http://github.com&lt;/a&gt;  ，&lt;a href=&quot;http://wallstreetcn.com&quot;&gt;http://wallstreetcn.com&lt;/a&gt; 或 &lt;a href=&quot;http://qiniu.com&quot;&gt;http://qiniu.com&lt;/a&gt; ; &lt;br /&gt;
第二组：&lt;a href=&quot;http://data.stats.gov.cn/&quot;&gt;http://data.stats.gov.cn/&lt;/a&gt; 或 &lt;a href=&quot;http://www.cbrc.gov.cn/&quot;&gt;http://www.cbrc.gov.cn/&lt;/a&gt;  &lt;br /&gt;
可以从地址栏上看到明显的返回结果的差异。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://postimg.cc/ctvWHXqK&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/NF4jdzpx/20161209github.png&quot; alt=&quot;github地址栏&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;尝试访问 &lt;a href=&quot;https://www.ssllabs.com/ssltest/index.html&quot;&gt;第三方SSL 测试平台&lt;/a&gt; &lt;br /&gt;
检测前面域名，也可以看到不同的测试结果返回。&lt;br /&gt;
&lt;a href=&quot;https://postimg.cc/xq8ntTk0&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/c1MC1v08/20161209wallstreetcn.png&quot; alt=&quot;sslLABS测试wallstreetcn.com结果&quot; /&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;建议&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果现在对整个事情的全貌有兴趣，你可以现在先阅读&lt;a href=&quot;#section-7&quot;&gt;第二部分 开始行动&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-3&quot;&gt;一 基础知识&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;1.1 部分名词&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CSP:&lt;br /&gt;
(Content Security Policy) ,http 响应头。用来告诉浏览器，在当前页面采用何种内容安全策略。 可减轻内容注入的风险，降低应用执行的权限，提升安全的 “ 厚度 ” 。但不是防御内容注入的首选。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;[Content Security Policy Level 3 的W3 官方文档]&lt;sup id=&quot;fnref:CSPl3&quot;&gt;&lt;a href=&quot;#fn:CSPl3&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;sample from w3.org：&lt;/em&gt; &lt;br /&gt;
  Given a page with the following Content Security Policy:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  
  Content-Security-Policy: child-src https://example.com/  
   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;Fetches for the following code will all return network errors, as the URLs provided do not match child-src’s source list:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;iframe src=&quot;https://not-example.com&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
  &amp;lt;script&amp;gt;
   var blockedWorker = new Worker(&quot;data:application/javascript,...&quot;);
  &amp;lt;/script&amp;gt;
 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Ocsp:&lt;br /&gt;
在线证书状态检查协议 (RFC6960 ) ，用来向 CA 站点查询证书状态，比如是否撤销。通常情况下，浏览器使用 OCSP 协议发起查询请求， CA 返回证书状态内容，然后浏览器接受证书是否可信的状态。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HSTS ：&lt;br /&gt;
(HTTP  Strict Transport Security)  a way for sites to elect to always use HTTPS 。 http 协议响应头。要求浏览器通过 https 来访问网站。
避免用户试图用 “http://” 访问时，通过 Web Server 的 301/302 重定向到 “https:// “ 方式（节省一个 RTT ）。
&lt;strong&gt;需要浏览器支持&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RTT ：&lt;br /&gt;
(round trip time ) （网络协议）交互时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SPDY :&lt;br /&gt;
（ means  SPEEDY ）。 Google 开发的，为了改善 Http1.x 的 TCP 应用层协议。 修改了 HTTP 的请求与应答在网络上传输的方式，当使用 SPDY 的方式传输， HTTP 请求会被处理、标记简化和压缩。 关键特性已被吸收到了 HTTP/2 协议中。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;1.2 规避已知的风险&lt;/h3&gt;

&lt;h4 id=&quot;section-6&quot;&gt;§ 漏洞及风险&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;规避已知的 HeartBleed 漏洞的涉及协议及产品版本  &lt;br /&gt;
2014 年 4 月漏洞暴露。    &lt;br /&gt;
对 2014 年 4 月前发布的基础系统，都要上官网确认是否存在安全漏洞，确认安装了必要的安全补丁。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;明确知道存在漏洞的基础系统（部分）    &lt;br /&gt;
centos  6 系列（ 6.5 ， 6.6 及以后，不含 7 以后） 涉及到 HeartBleed , 还包括 Shellshock, PODDLE 漏洞。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[Cent OS 官方对 HeartBleed ,PODDLE的安全说明] &lt;sup id=&quot;fnref:HeadBleed&quot;&gt;&lt;a href=&quot;#fn:HeadBleed&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;存在漏洞的协议  &lt;br /&gt;
OpenSSL 版本为 1.0.1 至 1.0.1f （含）。较新版本（ 1.0.1g 以上）及先前版本（ 1.0.0 分支以前）不受影响。 OpenSSL 最新版本 1.1.0c （ 2016-11-10 发布） 
SSL3.0 （ POODLE 攻击）， TLS1.0 （ 如 RC4 和 BEAST 攻击 ）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[Turn off SSL3.0 and TLS 1.0] &lt;sup id=&quot;fnref:SSL3&quot;&gt;&lt;a href=&quot;#fn:SSL3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;已知的加密算法的风险
    &lt;ul&gt;
      &lt;li&gt;MD5  ， SHA － 1 ，都不再适合用于密钥交换和加密通信（一致性校验）&lt;/li&gt;
      &lt;li&gt;RSA 算法需要使用 2048bit 或以上的密钥才能保证安全性（ 1024bit 密钥已经不再安全）&lt;/li&gt;
      &lt;li&gt;ECC 算法需要 224bit 以上的密钥才能保证安全性（通常为 256bit ）&lt;/li&gt;
      &lt;li&gt;RC4 （伪随机数流加密算法），已经在新版本 TLS 中被禁用   。&lt;br /&gt;
  google 使用的 ChaCha20 已经在 RFC 7539 中标准化  ,性能较之AES-GCM更好&lt;/li&gt;
      &lt;li&gt;TLS1.1 ， TLS1.2 尚未发现安全漏洞。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt; :&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[ 建议用 AES-GCM 取代RC4 ] &lt;sup id=&quot;fnref:AES-GCM&quot;&gt;&lt;a href=&quot;#fn:AES-GCM&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; &lt;br /&gt;
[ 通俗版椭圆曲线算法理论 ]&lt;sup id=&quot;fnref:pediy6014&quot;&gt;&lt;a href=&quot;#fn:pediy6014&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-7&quot;&gt;§ 针对协议与算法的常见攻击&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;BEAST:&lt;br /&gt;
  ( Browser Exploit Against SSL/TLS)&lt;br /&gt;
 利用块加密的特性，破解出密文中的某块明文，比如 cookies 中的 SessionKey 。
  TLS1.1 以后的版本已经修正了风险。但是攻击者可以通过 Downgrade Attack （参见：降级攻击）来试图迫使客户端降到 TLS1.0 来实施攻击。&lt;br /&gt;
&lt;strong&gt;参考&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;[ 一篇通俗易懂的 BEAST 原理的 BLOG ]&lt;sup id=&quot;fnref:BEAST&quot;&gt;&lt;a href=&quot;#fn:BEAST&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Downgrade Attack 降级攻击&lt;br /&gt;
 包括： 降级攻击一般包括两种：加密套件降级攻击 (cipher suite rollback) 和协议降级攻击（ version roll back ）。  &lt;br /&gt;
降级攻击的原理就是攻击者伪造或者修改 client hello 消息，使得客户端和服务器之间使用比较弱的加密套件或者协议完成通信。&lt;br /&gt;
&lt;strong&gt;参考&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;[ 利用 TLS_FALLBACK_SCSV 协议值来防止降级攻击 ]&lt;sup id=&quot;fnref:TLS_FB&quot;&gt;&lt;a href=&quot;#fn:TLS_FB&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;HeartBleed&lt;sup id=&quot;fnref:HeadBleed:1&quot;&gt;&lt;a href=&quot;#fn:HeadBleed&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;：  &lt;br /&gt;
 Heartbleed 是存在于 OpenSSL 加密软件库内的一个严重漏洞。此弱点让受保护的信息可以被盗取，它们本来是受 SSL ／ TLS 互联网加密协议所保护的。 SSL ／ TLS 为互联网上的应用程序提供安全通讯及私隐，这些程序包括有网页、电邮、即时通讯（ IM ）及某些虚拟专用网络（ VPN ）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;POODLE:&lt;br /&gt;
（ Padding Oracle On Downgraded Legacy Encryption ）。是协议降级攻击 version roll back 方式的一种。迫使浏览器降级至 SSL 3.0 而进行的中间人攻击。假若攻击者能成功利用此漏洞，他们平均只需 256 个 SSL 3.0 请求便能看穿加密信息内的 1 个字符。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TLS Renegotiation 重新协商攻击&lt;br /&gt;
 包括： 
 加密套件重协商 (cipher suite renegotiation )、 协议重商攻击（ Protocol Renegotiation ）两类。&lt;br /&gt;
&lt;strong&gt;最直接的保护手段是禁止客户端发起主动重新协商&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[Understanding_the_TLS_Renegotiation ]&lt;sup id=&quot;fnref:TLS_Ren&quot;&gt;&lt;a href=&quot;#fn:TLS_Ren&quot; class=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;XSS  攻击  &lt;br /&gt;
（ Cross-Site Scripting ）跨域脚本攻击   。在目标网站上执行非目标网站的原有脚本 。
既有利用浏览器漏洞，也有利用代码的漏洞进行脚本注入。通过 https 和响应头设置，可以减少
XSS 发生的可能。&lt;br /&gt;
&lt;strong&gt;参见服务端响应头相关内容&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-8&quot;&gt;二 开始行动&lt;/h2&gt;

&lt;h3 id=&quot;section-9&quot;&gt;2.1 首先要澄清的几个事项&lt;/h3&gt;

&lt;h4 id=&quot;https-&quot;&gt;§ 把域名切换到 https ，只是切换工作的一小部分&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;部署证书、修改 WebServer 配置支持 https 只是开始&lt;/li&gt;
  &lt;li&gt;所需加载的资源，如 js ， css ，图片等都需要加入考量范畴。否则，依旧存在劫持的可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;https--1&quot;&gt;§ https 的改造可以不考虑内部系统之间的调用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;但是，如果是跨局域网的内部服务间的交互，我们需要考虑敏感信息在链路上的安全&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cdn-&quot;&gt;§ 如果所需加载资源利用了第三方服务，如 CDN ，那么要做方案上的决策。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;信任 CDN ？ 把私钥交给 CDN ？&lt;br /&gt;
 &lt;strong&gt;相信 CDN 是安全的,这一行为本身就是不安全的。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;仅利用 CDN 的动态加速， TCP 代理，不缓存内容？  &lt;br /&gt;
 &lt;strong&gt;这样就大大降低了 CDN 的价值。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;寻找类似 CloudFlare ，提供 Keyless SSL 服务的 CDN 服务商。&lt;sup id=&quot;fnref:CloudF&quot;&gt;&lt;a href=&quot;#fn:CloudF&quot; class=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;     &lt;br /&gt;
&lt;strong&gt;不用提供私钥，不用使用公共域名和证书&lt;/strong&gt; &lt;br /&gt;
&lt;strong&gt;CloudFare 已经与百度合作&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;http--https-&quot;&gt;§ 把资源先改成 http 和 https 都支持？？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;注意修改代码中的链接 , 协议无关地址（ Protocol-less URLs ）。    &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;href=\&quot;http://...\&quot;    改为   href=\&quot;//...\&quot;&lt;/code&gt;             &lt;br /&gt;
&lt;strong&gt;问题：存在不兼容的可能，上线前需要严格测试&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;https--http-&quot;&gt;§ https 下重建连接的代价成本要远比 http 高&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;http/2 的头部压缩（ header compression ） , 连接多路复用（ one connection for parallelism ）等可以改善 TLS 带来的成本。  &lt;br /&gt;
&lt;strong&gt;目前平均每个页面有 80 个部件 (Assets) ，平均每个头 (Header) 有 1400bytes&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;http/2 可以完全兼容 http1.1&lt;br /&gt;
&lt;strong&gt;参考&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;[HTTP2 的 FAQ]&lt;sup id=&quot;fnref:HTTP2&quot;&gt;&lt;a href=&quot;#fn:HTTP2&quot; class=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-10&quot;&gt;§ 必须关注证书采购的成本&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;购买证书的投入，包括首次购买及续费成本&lt;/li&gt;
  &lt;li&gt;未来运维管理的成本&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;server-&quot;&gt;§  协议支持的，未必代表厂商（浏览器， Server 等）支持&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;必须要用特定的配置（兼容）清单 去验证所有的修改&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;step-by-step&quot;&gt;2.2 主要行动Step by Step&lt;/h3&gt;

&lt;h4 id=&quot;step1-ca&quot;&gt;§ Step1 申请（购买）CA证书&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;需要根据自身业务使用域名的实况来确定采购的证书类型和数量。&lt;br /&gt;
对现有域名资源进行适当的梳理和规划，可以节省证书和未来运维的成本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DV(Domain Validation SSL Certificate ) ,OV( Organization Validation SSL Certificate ),EV(  Extended Validation SSL Certificate )  与保护的域名数量之间没有直接关联&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SAN SSL 证书   Subject Alternative Name certificates 又称为 UCC 证书 – Unified Communication Certificates. &lt;br /&gt;
  可以保护若干数量的域名。超过默认数量，可能需要支付额外费用 。   （具体视厂商而定）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通配符 证书   Wildcard SSL  Certificate    ， 也称为泛域名证书，&lt;br /&gt;
 可以保护下一级的子域名，及其本身。  &lt;br /&gt;
 即：如要保护多个四级域名，需要购买针对三级域名的通配符型的证书。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不同的 CA 证书供应商，价格差异较大。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;正在兴起的 &lt;strong&gt;Let’s Encrypt&lt;/strong&gt;免费证书&lt;sup id=&quot;fnref:Letsen&quot;&gt;&lt;a href=&quot;#fn:Letsen&quot; class=&quot;footnote&quot;&gt;11&lt;/a&gt;&lt;/sup&gt; , &lt;sup id=&quot;fnref:acme-tiny&quot;&gt;&lt;a href=&quot;#fn:acme-tiny&quot; class=&quot;footnote&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如：需要保护类似 ＊ .weixin.example.com , ＊ .api.weixin.example.com ，以及上层的 example.com 和 ＊.example.com&lt;br /&gt;
&lt;strong&gt;【需要两张泛域名证书】&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;step2--&quot;&gt;§ Step2  生成和下载证书&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;证书供应商会都会提供管理和生成、下载证书的管理入口&lt;/li&gt;
  &lt;li&gt;每张证书都是和特定的一个或者一组域名的保护相关联（生成）的&lt;/li&gt;
  &lt;li&gt;将下载证书部署到服务端特定的位置&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;step3-cipher-suite&quot;&gt;§ Step3 选择加密套件Cipher Suite&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;每个利用 https 的客户端都有一组支持的加密套件（ Cipher Suite ），&lt;br /&gt;
如果这组套件与服务器上的套件列表没有交集，则无法完成协商，握手失败。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每个套件都是一组算法存在的，其中一般包含：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;密钥交换（ Key Exchange ）&lt;/li&gt;
      &lt;li&gt;证书签名认证（ Authentication ）&lt;/li&gt;
      &lt;li&gt;加密算法（ Encrytion ）&lt;/li&gt;
      &lt;li&gt;内容完整性（一致性）校验算法（ Message Authentication Code ，简称 MAC ）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[iana.org 管理的完整套件列表 ]&lt;sup id=&quot;fnref:iana&quot;&gt;&lt;a href=&quot;#fn:iana&quot; class=&quot;footnote&quot;&gt;13&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;openssl 不同版本支持的套件不同，可以通过命令查看：  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt; $ openssl ciphers -V | column -t&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;命令运行后，展现以下形式内容 , 其中第一列为套件的编号：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  0xC0,0x30  -  ECDHE-RSA-AES256-GCM-SHA384    TLSv1.2  Kx=ECDH        Au=RSA    Enc=AESGCM(256)    Mac=AEAD  
  0xC0,0x2C  -  ECDHE-ECDSA-AES256-GCM-SHA384  TLSv1.2  Kx=ECDH        Au=ECDSA  Enc=AESGCM(256)    Mac=AEAD  
  0xC0,0x28  -  ECDHE-RSA-AES256-SHA384        TLSv1.2  Kx=ECDH        Au=RSA    Enc=AES(256)       Mac=SHA384  
  0xC0,0x24  -  ECDHE-ECDSA-AES256-SHA384      TLSv1.2  Kx=ECDH        Au=ECDSA  Enc=AES(256)       Mac=SHA384  
  0xC0,0x14  -  ECDHE-RSA-AES256-SHA           SSLv3    Kx=ECDH        Au=RSA    Enc=AES(256)       Mac=SHA1  
  0xC0,0x0A  -  ECDHE-ECDSA-AES256-SHA         SSLv3    Kx=ECDH        Au=ECDSA  Enc=AES(256)       Mac=SHA1  
  0xC0,0x22  -  SRP-DSS-AES-256-CBC-SHA        SSLv3    Kx=SRP         Au=DSS    Enc=AES(256)       Mac=SHA1  
....  

&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;非对称密钥交换算法 key Exchange 。    &lt;br /&gt;
建议优先使用 ECDHE ，禁用 DHE ，次优先选择 RSA 。&lt;/li&gt;
    &lt;li&gt;证书签名算法 。  &lt;br /&gt;
由于部分浏览器及操作系统不支持 ECDSA 签名，目前默认都是使用 RSA 签名，其中 SHA1 签名已经不再安全， &lt;strong&gt;chrome 及微软 2016 年开始不再支持 SHA1 签名的证书&lt;/strong&gt; &lt;sup id=&quot;fnref:SHA1&quot;&gt;&lt;a href=&quot;#fn:SHA1&quot; class=&quot;footnote&quot;&gt;14&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
    &lt;li&gt;对称加解密算法。    &lt;br /&gt;
优先使用 AES-GCM 算法，针对 1.0 以上协议禁用 RC4 （rfc7465）。&lt;/li&gt;
    &lt;li&gt;内容一致性校验算法。    &lt;br /&gt;
Md5 和 SHA1 都已经不安全，建议使用 SHA256 等安全哈希函数。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;step4--&quot;&gt;§ Step4  修改服务器配置&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;修改 Nginx 配置 （包括指定证书的路径）&lt;/li&gt;
  &lt;li&gt;是否在 Nginx 的配置中加入不同的响应头，需要小心评估。  &lt;br /&gt;
例如： 如下响应头可以自动将 http 资源请求，升级会 https 请求。&lt;br /&gt;
（需要保证资源路径相同，包括第三方资源可支持 https ）&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;W3.org上的例子 &lt;a href=&quot;https://www.w3.org/TR/upgrade-insecure-requests/&quot;&gt;https://www.w3.org/TR/upgrade-insecure-requests/&lt;/a&gt; :&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  server {
    ...

    add_header Content-Security-Policy upgrade-insecure-requests;

    ...
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;下载 openSSL 包&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;示例 &lt;a href=&quot;https://github.com/diafygi/acme-tiny &quot;&gt;https://github.com/diafygi/acme-tiny &lt;/a&gt; : &lt;sup id=&quot;fnref:acme-tiny:1&quot;&gt;&lt;a href=&quot;#fn:acme-tiny&quot; class=&quot;footnote&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    server {  
      listen 443;  
      server_name yoursite.com, www.yoursite.com;   
      ssl on;  
      ssl_certificate /path/to/chained.pem;  
      ssl_certificate_key /path/to/domain.key;  
      ssl_session_timeout 5m;  
      ssl_protocols TLSv1.1 TLSv1.2;  
      ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA;  
      ssl_session_cache shared:SSL:50m;  
      ssl_dhparam /path/to/server.dhparam;  
      ssl_prefer_server_ciphers on;   
      ...the rest of your config  
    } 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;更多内容可参见后文 &lt;a href=&quot;#section-10&quot;&gt;重点行动项的进一步说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[ 官方 Module ngx_http_ssl_module]&lt;sup id=&quot;fnref:ngx_http&quot;&gt;&lt;a href=&quot;#fn:ngx_http&quot; class=&quot;footnote&quot;&gt;15&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;step5-&quot;&gt;§ Step5 修改代码&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;采用 https 协议 “https://…” ，或者改为 协议无关的方式 “ //…” &lt;br /&gt;
改为协议无关 “//…” 方式，是种很有风险的方式，存在网络供应商篡改，导致资源路径失败的可能&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;页面从存在任何不安全的链接（ http ），浏览器地址栏的小绿锁 就会消失。    &lt;br /&gt;
 **要去掉所有可能导致警告和绿锁消失的链接 **&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注意可能从配置文件 或者 数据库字段中生成的 地址&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;注意所有的外链和外部接口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;[Move a site with URL changes]&lt;sup id=&quot;fnref:Move&quot;&gt;&lt;a href=&quot;#fn:Move&quot; class=&quot;footnote&quot;&gt;16&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
    &lt;li&gt;[RFC3986]&lt;sup id=&quot;fnref:RFC3986&quot;&gt;&lt;a href=&quot;#fn:RFC3986&quot; class=&quot;footnote&quot;&gt;17&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;final-step--&quot;&gt;§ final Step  监控日志&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;必须关注和分析服务器日志，确定资源请求失败的客户端，或者资源本身。&lt;/li&gt;
  &lt;li&gt;监控日志，只是一轮改造的最后一步，更可能是新一轮迭代的开始。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-11&quot;&gt;三 重点行动项的进一步说明&lt;/h2&gt;

&lt;h3 id=&quot;section-12&quot;&gt;3.1 证书问题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;通过 Nginx ，在同一 IP 上部署多个 HTTPS 站点，会存在证书冲突的问题   ，除了 SNI （ Server Name Indication ）外，利用 SAN 证书也可以解决这个问题    &lt;br /&gt;
&lt;strong&gt;Windows XP IE6~8 、 Android 2.x Webview 都不支持 SNI&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-13&quot;&gt;3.2 服务端响应头&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;参考示例&lt;/strong&gt;
可以参考和研究其它网站的响应头，然后结合自身实况来决定怎么做&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Google:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  x-content-type-options: nosniff  
  x-frame-options: SAMEORIGIN  
  x-xss-protection: 1 ; mode=block  

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Twitter:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  strict-transport-security: max-age= 631138519
  x-frame-options: SAMEORIGIN
  x-xss-protection: 1 ; mode=block
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;PayPal:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  X-Frame-Options: SAMEORIGIN
  Strict-Transport-Security: max-age= 14400
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Facebook 则使用了这些（配置了详细的 CSP ，关闭了 XSS 保护）:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  strict-transport-security: max-age= 60
  x-content-type-options: nosniff
  x-frame-options: DENY
  x-xss-protection: 0
  content-security-policy: default-src *;script-src https://*.facebook.com http://*.facebook.com https://*.fbcdn.net http://*.fbcdn.net *.facebook.net *.google-analytics.com *.virtualearth.net *.google.com 127.0 . 0.1 :* *.spotilocal.com:* chrome-extension://lifbcibllhkdhoafpjfnlhfpfgnpldfl 'unsafe-inline' 'unsafe-eval' https://*.akamaihd.net http://*.akamaihd.net;style-src * 'unsafe-inline' ;connect-src https://*.facebook.com http://*.facebook.com https://*.fbcdn.net http://*.fbcdn.net *.facebook.net *.spotilocal.com:* https://*.akamaihd.net ws://*.facebook.com:* http://*.akamaihd.net https://fb.scanandcleanlocal.com:*;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-14&quot;&gt;3.3 让交互更快的策略&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;参考建议&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;采取任何优化策略前，先要对内部基础设施（包括web server，用户浏览器使用分布等），做清晰梳理。然后再寻找、评估和采用针对性的策略。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;tcp-fast-open&quot;&gt;§ TCP FAST OPEN&lt;/h4&gt;
&lt;p&gt;RFC7413&lt;br /&gt;
  TFO 需要高版本内核的支持， linux 从 3.7 以后支持 TFO ，但是目前的 windows 系统还不支持 TFO ，所以只能在公司内部服务器之间发挥作用。&lt;/p&gt;

&lt;h4 id=&quot;ocsp-stapling&quot;&gt;§ OCSP Stapling&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;OCSP 方式向 CA 站点检查证书状态请求， CA 返回证书状态（是否有效／可信／撤销等）的过程，会因为 CA 站点服务器的位置，网络的稳定性等因素，会额外消耗大量 RTT 的时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OCSP 装订 /( 封套 ). 是一个 TLS 证书状态查询扩展，作为在线证书状态协议的代替方法对 X.509 证书状态进行查询   。
  服务器在 TLS 握手时发送事先缓存的 OCSP 响应，用户只需验证该响应的有效性而不用再向数字证书认证机构（ CA ）发送请求。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;服务器端的支持情况：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;
  Httpd ： 2.3.3          
  Nginx ： 1.3.7  
  IIS ： Windows Server 2008  
  HAProxy ： 1.5.0  
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;浏览器的支持情况：主流浏览器都已获得支持。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Nginx 开启配置的方式  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ssl_stapling on;ssl_stapling_file ocsp.staple;
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[OCSP_Stapling,wikipedia ]&lt;sup id=&quot;fnref:OCSP&quot;&gt;&lt;a href=&quot;#fn:OCSP&quot; class=&quot;footnote&quot;&gt;18&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;session--session--resume-&quot;&gt;§ Session 复用（ Session  Resume ）的两种方式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Session Cache &amp;amp;  Session Ticket &lt;br /&gt;
通过在服务端缓存已有的 Session 握手信息来实现：避免再次计算和非对程密钥的交换，节省一个 RTT 交互时间和计算成本。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;策略&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;存储方式&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;存储容量&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;恢复方式&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;共享能力&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;优缺点与风险&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;session cache&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;服务端内存&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4K session/M&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通过 Session id 查找&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;单机多进程间&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;浏览器支持度高，不支持分布式，消耗内存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;session ticket&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;服务端文件&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通过 Session 本身（加密成 ticket ）&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;可以在多个 Server 间共享&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持度略低，需维护 ticket 加解密的额外 key&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;为了保证 Session Tickets 的可复用，在 配置Nginx 时不要使用 web server 随机生成的保存文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[nginx 官方 ssl_session_ticket_key]&lt;sup id=&quot;fnref:ticket&quot;&gt;&lt;a href=&quot;#fn:ticket&quot; class=&quot;footnote&quot;&gt;19&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;app&quot;&gt;3.4 APP周边相关&lt;/h3&gt;
&lt;p&gt;#### § 原生功能的安全
  - 仅使用 MD5 的 token 是很容易被伪冒的。对于涉及资金的交易，显然不够；  需要同时利用［敏感内容先加密（如 利用 RSA 算法），同时完整交易信息签名验证（比如利用 appKey+appSecret+userName+tradeTime
，进行 MD5 或者 SHA256 ）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;进一步提高安全性： &lt;br /&gt;
  每天至少进行一次握手，交换和更新下 token （密钥）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;h5-&quot;&gt;§ 内嵌H5 页面的安全&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以选择高层或底层的不同方式&lt;br /&gt;
  （如 android 的 HttpsURLConnection ，或 SSLSocket ） &lt;br /&gt;
  &lt;strong&gt;参考&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/best-security.html&quot;&gt;Android 官方 : Best Practices for  Security and Privacy&lt;/a&gt; &lt;sup id=&quot;fnref:Android&quot;&gt;&lt;a href=&quot;#fn:Android&quot; class=&quot;footnote&quot;&gt;20&lt;/a&gt;&lt;/sup&gt;   &lt;br /&gt;
&lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33&quot;&gt;ios  官方： App Transport Security (ATS) &lt;/a&gt; &lt;sup id=&quot;fnref:ATS&quot;&gt;&lt;a href=&quot;#fn:ATS&quot; class=&quot;footnote&quot;&gt;21&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-15&quot;&gt;3.5 测试与验证&lt;/h3&gt;

&lt;h4 id=&quot;section-16&quot;&gt;§ 工具&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;免费的第三方检测平台。&lt;br /&gt;
如：&lt;a href=&quot;https://www.ssllabs.com/ssltest/index.html&quot;&gt;ssl Labs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-17&quot;&gt;五 结语&lt;/h2&gt;

&lt;p&gt;回到本文的最前面，如果你只是想让你的网站，在地址栏出现一个“小绿锁”（也许它会时隐时现），那么一切都比较简单。借助cloudflare 提供的服务，也许只要半个小时就看上去万事大吉了。&lt;/p&gt;

&lt;p&gt;但是，对于一个有一定规模的网站来说，向https 、 http/2 的切换，目标显然不仅是看上去有了个“小绿锁”。真正实现在安全层面的提升和切换，一定会是一个艰难和充满风险的过程。&lt;/p&gt;

&lt;h2 id=&quot;section-18&quot;&gt;六 延伸阅读&lt;/h2&gt;

&lt;h3 id=&quot;section-19&quot;&gt;6.1 来自其它公司的实践&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;大型网站的https实践(百度)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://op.baidu.com/2015/04/https-s01a01/&quot;&gt;http://op.baidu.com/2015/04/https-s01a01/&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;淘宝的https探索&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf&quot;&gt;http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-20&quot;&gt;6.2  其他链接&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.nginx.com/blog/nginx-1-9-5/&quot;&gt;nginx官方: Open Source Nginx 1.9.5  Released with  HTTP/2 support&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000004232801&quot;&gt;nginx1.8.x 配置 https&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;参考索引&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:CSPl3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.w3.org/TR/CSP/&quot;&gt;Content Security Policy Level 3 的W3 官方文档&lt;/a&gt; &lt;a href=&quot;#fnref:CSPl3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:HeadBleed&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://wiki.centos.org/zh/Security&quot;&gt;Cent OS 官方对 HeartBleed ,PODDLE的安全说明&lt;/a&gt; &lt;a href=&quot;#fnref:HeadBleed&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:HeadBleed:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:SSL3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.ssl.com/how-to/turn-off-ssl-3-0-and-tls-1-0-in-your-browser/&quot;&gt;Turn off SSL3.0 and TLS 1.0&lt;/a&gt; &lt;a href=&quot;#fnref:SSL3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:AES-GCM&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://blogs.technet.microsoft.com/srd/2013/11/12/security-advisory-2868725-recommendation-to-disable-rc4/&quot;&gt; 建议用 AES-GCM 取代RC4 &lt;/a&gt; &lt;a href=&quot;#fnref:AES-GCM&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:pediy6014&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.pediy.com/kssd/pediy06/pediy6014.htm&quot;&gt; 通俗版椭圆曲线算法理论 &lt;/a&gt; &lt;a href=&quot;#fnref:pediy6014&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:BEAST&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://securityalley.blogspot.com/2014/07/ssltls-beast.html&quot;&gt;一篇通俗易懂的 BEAST 原理的 BLOG &lt;/a&gt; &lt;a href=&quot;#fnref:BEAST&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:TLS_FB&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00#page-3&quot;&gt;ietf: 利用 TLS_FALLBACK_SCSV 协议值来防止降级攻击 &lt;/a&gt; &lt;a href=&quot;#fnref:TLS_FB&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:TLS_Ren&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.educatedguesswork.org/2009/11/understanding_the_tls_renegoti.html&quot;&gt;Understanding_the_TLS_Renegotiation&lt;/a&gt; &lt;a href=&quot;#fnref:TLS_Ren&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:CloudF&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.cloudflare.com/ssl/&quot;&gt;Cloudflare one-click SSL&lt;/a&gt; &lt;a href=&quot;#fnref:CloudF&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:HTTP2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://http2.github.io/faq/&quot;&gt;HTTP2的FAQ&lt;/a&gt; &lt;a href=&quot;#fnref:HTTP2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:Letsen&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://letsencrypt.org/getting-started/&quot;&gt;Let’s Encrypt 免费证书&lt;/a&gt; &lt;a href=&quot;#fnref:Letsen&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:acme-tiny&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://github.com/diafygi/acme-tiny&quot;&gt;issue and renew Let’s Encrypt certificates&lt;/a&gt; &lt;a href=&quot;#fnref:acme-tiny&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:acme-tiny:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:iana&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4&quot;&gt;iana.org 管理的完整套件列表&lt;/a&gt; &lt;a href=&quot;#fnref:iana&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:SHA1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://googleonlinesecurity.blogspot.jp/2014/09/gradually-sunsetting-sha-1.html&quot;&gt;chrome 及微软 2016 年开始不再支持 SHA1 签名的证书&lt;/a&gt; &lt;a href=&quot;#fnref:SHA1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ngx_http&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_ssl_module.html&quot;&gt;官方:配置 Module ngx_http_ssl_module &lt;/a&gt; &lt;a href=&quot;#fnref:ngx_http&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:Move&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://support.google.com/webmasters/answer/6033049?hl=en&amp;amp;ref_topic=6033084&amp;amp;rd=1&quot;&gt;Google:  Move a site with URL changes&lt;/a&gt; &lt;a href=&quot;#fnref:Move&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:RFC3986&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;RFC3986:(URI): Generic Syntax&lt;/a&gt; &lt;a href=&quot;#fnref:RFC3986&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:OCSP&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/OCSP_stapling&quot;&gt;OCSP_Stapling,wikipedia&lt;/a&gt; &lt;a href=&quot;#fnref:OCSP&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ticket&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_session_ticket_key&quot;&gt;nginx官方：ssl_session_ticket_key&lt;/a&gt; &lt;a href=&quot;#fnref:ticket&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:Android&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/best-security.html&quot;&gt;Android官方: Best Practices for  Security and Privacy&lt;/a&gt; &lt;a href=&quot;#fnref:Android&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ATS&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33&quot;&gt;ios 官方： App Transport Security (ATS) &lt;/a&gt; &lt;a href=&quot;#fnref:ATS&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Ryan Wang (Haide1977)</name><email>haide1977 AT gmail.com</email></author><category term="架构" /><category term="互联网" /><category term="基础系统" /><summary type="html">研究目标

  整理 https 相关的基本知识；
  梳理现存网站全面转向 https 的相关行动事项；</summary></entry><entry><title type="html">从零开始的平台总体安全体系的考量</title><link href="http://0.0.0.0:4000/2016/10/18/System_Security-Considerations_From_Scratch.html" rel="alternate" type="text/html" title="从零开始的平台总体安全体系的考量" /><published>2016-10-18T00:00:00+08:00</published><updated>2016-10-18T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2016/10/18/System_Security%20Considerations_From_Scratch</id><content type="html" xml:base="http://0.0.0.0:4000/2016/10/18/System_Security-Considerations_From_Scratch.html">&lt;p&gt;现在互联网的新生平台比以往面临着更复杂的技术环境。平台一上线，即面临着全方位、体系性的安全风险考验。以如下几方面情况的引入，可能衍生的安全风险尤为突出：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;面向多种类型端的用户APP产品入口的推出&lt;/li&gt;
  &lt;li&gt;更加复杂的用户权益账户、储值类电子账户的引入， 如 &lt;strong&gt;积分、内置钱包等&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;平台自有的多个支付渠道和多类型收付交易行为的引入， 如 &lt;strong&gt;三方支付、交易中途改变支付方式等&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;更加复杂的结算和清算场景 ， 如 &lt;strong&gt;用户奖励提现，外部积分互换等&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;更加复杂的业务和个性化的促销策略， 如 &lt;strong&gt;折扣策略、优惠券和羊毛党等&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;以及，快速的业务场景和功能的演进。&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;p&gt;对于很多新生的互联网业务平台来说，受制于诸多约束，多数时候是暴露在各类安全风险下前进的。本文并非要阐述如何建设一个高标准的、高等级的信息安全体系，而是，站在从零开始的场景下，梳理一个相对体系化的考量框架。毕竟，最大的风险是来自对风险的无知。如何在有限资源投入的情况下，作出各种权衡，使安全体系建设和平台发展演进相适应，才是我们真正要关注的。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;一 系统的总体安全目标&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;安全板块划分&lt;/th&gt;
      &lt;th&gt;总体目标&lt;/th&gt;
      &lt;th&gt;备注说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;运营&lt;/td&gt;
      &lt;td&gt;安全应急响应与风控体系&lt;/td&gt;
      &lt;td&gt;运营全流程及体系角度来统筹推进建设&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;基本防护&lt;/td&gt;
      &lt;td&gt;基本的安全攻防体系&lt;/td&gt;
      &lt;td&gt;提高系统被攻击的门槛&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;运维&lt;/td&gt;
      &lt;td&gt;安全管理与审计&lt;/td&gt;
      &lt;td&gt;合适权限的人和系统，访问合适权限的数据和服务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;监控与告警&lt;/td&gt;
      &lt;td&gt;实时安全监控与安全扫描&lt;/td&gt;
      &lt;td&gt;如何及时发现问题；合理的确定告警项和等级&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;研发&lt;/td&gt;
      &lt;td&gt;安全软件的开发框架&lt;/td&gt;
      &lt;td&gt;使功能团队相对专注功能开发，引入安全风险的几率降低。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;二 安全体系构建的基本思路&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;体系化建设推进，&lt;strong&gt;避免&lt;/strong&gt;出现安全板块的 &lt;strong&gt;明显短板&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;与产品与运营发展的相匹配，注重 &lt;strong&gt;投入产出比&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;关键在于 &lt;strong&gt;风险可控&lt;/strong&gt;，不断提升自我保护能力&lt;/li&gt;
  &lt;li&gt;不断提升攻击成本，控制、降低被攻击的损失&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;平衡&lt;/strong&gt;用户产品使用的便利性和安全性&lt;/li&gt;
  &lt;li&gt;不要混淆用户的 &lt;strong&gt;安全感诉求&lt;/strong&gt; 和真正的 &lt;strong&gt;系统安全需求&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;借鉴和研发并举， &lt;strong&gt;避免闭门造车&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;三 安全角度的非功能性需求建设&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;3.1 可测试性&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;优先级1&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;测试是验证体系安全和质量的最后一道屏障，&lt;/li&gt;
  &lt;li&gt;必须首先建立对体系安全评估的测试能力。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;section-4&quot;&gt;先想好怎么测试和验证，再思考开发实现&lt;/h4&gt;
  &lt;hr /&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为在一开始几乎不可能有充足资源搭建强有力的测试团队。技术团队，尤其要建立这样的团队意识和基本的技术支撑。否则，随着业务功能的演进，技术团队必然陷入忙于救火，甚至乱上加乱的态势。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;3.2 可追溯性&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;优先级1&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;安全的基石是所有系统和用户行为的可追溯。
    &lt;ul&gt;
      &lt;li&gt;没有相适应的追溯体系，监控、告警、分析、改进都会无从谈起。&lt;/li&gt;
      &lt;li&gt;运营层面的个案分析、责任划分甚至赔付等都难以开展。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;系统内数据和日志的完整性和不可抵赖性，是追溯合法性关键。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;section-6&quot;&gt;日志记录的搜集、检索能力，是可追溯的技术基础&lt;/h4&gt;
  &lt;hr /&gt;
&lt;/blockquote&gt;

&lt;p&gt;暂时没有完整的日志运用平台不要紧；没有现成日志记录规范也不要紧；检索起来有点笨拙也不太要紧；
但是技术团队在代码评审时候，必须意识到，某些代码段，必须要在运行时候，记录下点什么，并且确保能记录下来。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;3.3 安全性&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;优先级1&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户数据安全性
    &lt;ul&gt;
      &lt;li&gt;涵盖：用户隐私数据、用户交易数据、用户认证数据&lt;/li&gt;
      &lt;li&gt;要求：展示层、存储层、内部交互层面、外部通信层面&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;系统交易安全性
    &lt;ul&gt;
      &lt;li&gt;人为操作导致的交易损失［主观故意｜过失］&lt;/li&gt;
      &lt;li&gt;系统BUG导致的交易损失［设计缺陷｜实现缺陷］&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;section-8&quot;&gt;建立多层次的防控体系， 对业务流程建立主题式风险表&lt;/h4&gt;
  &lt;hr /&gt;
&lt;/blockquote&gt;

&lt;p&gt;用户数据的泄漏，已然是这几年见怪不怪的新闻了。泄漏事件一旦进入公众视野，对于平台业务的成长打击是显而易见的。很多时候，泄漏都不是源于技术高超的攻击，而不过是内部管理缺陷和安全意识的淡薄的结果。 &lt;br /&gt;
对成长中的团队，如果技术手段跟不上，那么先考虑实现基本的安全原则，以及更加严格的数据权限纪律1，2，3…。作为团队领导，必须有足够的安全敏感度，清晰的意识到哪些事情是必须首先做的。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;3.4 可监控 可报警&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;优先级1&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可监控
    &lt;ul&gt;
      &lt;li&gt;对所有交易，尤其是“钱”相关的操作，能及时发现问题。&lt;br /&gt;
 &lt;em&gt;监控什么？ 怎么监控？ 投入多少资源？&lt;/em&gt;需要团队共同梳理清楚，排进工作中。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;可报警
    &lt;ul&gt;
      &lt;li&gt;报警的目的是避免风险扩大、蔓延.&lt;/li&gt;
      &lt;li&gt;确定处理策略的依据    &lt;br /&gt;
 &lt;em&gt;确定告警项 确定告警的依据模型  确定警告散发的方式&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;section-10&quot;&gt;确定优先级表格，技术研发和运营、运维要结合联动&lt;/h4&gt;
  &lt;hr /&gt;
&lt;/blockquote&gt;

&lt;p&gt;信息安全体系的构建是全平台包括技术研发、运维、业务运营及客户服务等各个团队的职责。对于快速成长的平台，尤其需要高效联动，才能保证问题早发现，响应处理更高效。从而，满足用户的安全感诉求、保证用户体验，维护用户对平台的信任感。&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;3.5 内部操作安全性&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;优先级1&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上线操作风险&lt;/li&gt;
  &lt;li&gt;生产环境变更风险／配置管理风险&lt;/li&gt;
  &lt;li&gt;跨流程（跨产品线）交易修改操作风险&lt;/li&gt;
  &lt;li&gt;代码审核风险［如测试代码和参数被发布上线］&lt;/li&gt;
  &lt;li&gt;测试风险［如测试数据］&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;section-12&quot;&gt;建立明确、合理、严格的操作和评审规范&lt;/h4&gt;
  &lt;hr /&gt;
&lt;/blockquote&gt;

&lt;p&gt;制度和规范的建立需要一个过程。从别的团队照搬过来的一整套貌似完整的制度规范，在创业团队中，多数会成为摆设。若干条切中要害的研发纪律产生的效果可以是立竿见影的。从简单的几条研发纪律开始，逐步演进，完善，最终可以形成操作性强，适应实际的规范和制度。&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;3.6 系统基本自我保护能力&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;优先级1&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;容错能力
    &lt;ul&gt;
      &lt;li&gt;发生预期失败时，系统自己解决问题，防止应用失败。 &lt;br /&gt;
   &lt;code class=&quot;highlighter-rouge&quot;&gt;比如自动路由功能，保证一个通道失败时，寻找新通道等。&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;快速失败原则
    &lt;ul&gt;
      &lt;li&gt;防止系统进入不完整运行态（比如半吊子流程）&lt;/li&gt;
      &lt;li&gt;防止因为某个失败、系统进入无休止的等待（比如利用超时设置）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;服务降级
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;当服务的访问量超出预期吞吐能力时，通过降级来保证服务质量，而不是让服务不降级但全部不可 &lt;br /&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;降级策略不是个单纯技术问题，典型问题如：ERP库存无法读取时，是否在线商城就不让购买了？？&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;自动降级还是手动降级，也是一个问题。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;资源限制与管控
    &lt;ul&gt;
      &lt;li&gt;系统资源不做管控，一定会在某个时间点发生事故。 &lt;br /&gt;
   &lt;code class=&quot;highlighter-rouge&quot;&gt;管控资源的基本准则是不让局部出现资源短板，而导致体系崩溃。&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zhongkerd.com/news/content-545.html&quot;&gt;关于降级的一篇参考的文档&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;section-14&quot;&gt;技术团队完全有责任不让用户陷入“系统又挂了”的惯性信任危机思维中&lt;/h4&gt;
  &lt;hr /&gt;
&lt;/blockquote&gt;

&lt;p&gt;极端情况下，当内部业务和运营团队都有这样的思维惯性时，技术团队的工作开展将变得困难。重建信任的过程是异常困难的。&lt;br /&gt;
举个例子，如果在系统响应能力不够时，较之卡死不动，而是直接跳转到友情提示页面，带给用户的感觉是完全不同的。让用户清晰知道，当前平台的服务能力是有限的，这不丢人，用户多数时候也会理解；但是绝不能让用户感觉到，技术团队对平台的状态是茫然和失控的。&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;3.7 避免雪崩效应&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;优先级2&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有涉及到第三方的接入都要加入防雪崩效应的策略&lt;/li&gt;
  &lt;li&gt;不能假设第三方服务不会延迟、宕机。&lt;/li&gt;
  &lt;li&gt;不能因为某个第三方服务的失败而拖垮平台本身。&lt;/li&gt;
  &lt;li&gt;不能因为某个用户的某些操作行为，而拖垮其它用户的正常交易。&lt;/li&gt;
  &lt;li&gt;对于不同类型、业务频率、实时性要求的业务，要放在不同消息通道里处理。&lt;/li&gt;
  &lt;li&gt;防止外挂系统来影响正常业务&lt;/li&gt;
  &lt;li&gt;如系统日志、监控等，目的是为了支撑业务系统，要防止反过来影响业务系统。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;section-16&quot;&gt;建立对雪崩场景的压力测试用例，并进行测试&lt;/h4&gt;
  &lt;hr /&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过monk、压测，是在团队早期，功能上线频繁，需求不稳定，测试工作不完善的情况下，性价很高的早发现问题的方法。很大部分设计、代码的缺陷，在一定的压力下会比较容易暴露出来。&lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;3.8 应对活动和促销&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;优先级2&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;活动和促销带来的突发流量和并发的应对
    &lt;ul&gt;
      &lt;li&gt;结合压力测试和资源估算模型，建立对平台能力的基本判断&lt;/li&gt;
      &lt;li&gt;形成基本的活动和促销的方案预案［技术｜运营｜…］&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;部分商家的活动和促销对其他商家的资源挤占的应对
    &lt;ul&gt;
      &lt;li&gt;架构上，要具备基本的资源隔离能力（除非接入带宽被完全挤占）&lt;/li&gt;
      &lt;li&gt;降级和资源管控策略相集合。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;section-18&quot;&gt;需要从公司层面进行统筹&lt;/h4&gt;
  &lt;hr /&gt;
&lt;/blockquote&gt;

&lt;p&gt;活动和促销，已经成为很多平台暴力演进的常态化工具。并非一般意义上的安全体系问题，但是往往会引发一些潜在安全漏洞的暴露。比如促销、优惠券使用存在的潜在漏洞；或者诱人的活动，引来一些潜在的系统攻击者；当然，也不排除一些恶意的刷爆平台第三方服务的预存款行为等。这些都需要技术团队事先有所预见。&lt;/p&gt;

&lt;h3 id=&quot;section-19&quot;&gt;3.9 可配置&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;优先级2&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;业务层面系统参数的变化，尽量避免停机或者重启&lt;br /&gt;
 &lt;code class=&quot;highlighter-rouge&quot;&gt;如：关键服务的下架；部分系统进入维护，部分系统临时隔离等等&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;非功能性需求的实现，需要存在人工干预人口的场景&lt;br /&gt;
 &lt;code class=&quot;highlighter-rouge&quot;&gt;如：资源管控，降级策略的调整等等&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;section-20&quot;&gt;自动化当然好，但是很难一步到位；图形化当然好，但不是不可或缺&lt;/h4&gt;
  &lt;hr /&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个问题的本质，还是技术团队（包括运维），对平台的真正的控制力。这里控制力，不是说你有每个服务器的密码和服务重启的权限。而是你对你所有服务和每个服务在用、可用资源都能比较清晰的掌握，并在此基础上，可以实现高效的管控，调配。&lt;/p&gt;

&lt;h3 id=&quot;section-21&quot;&gt;3.10 避免单点故障&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;优先级2&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;单点的故障，往往不是预期会出现故障的故障点。 &lt;br /&gt;
 &lt;code class=&quot;highlighter-rouge&quot;&gt;往往也不是软件本身导致的故障&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于短时间无法消除的单点风险，要准备失败－恢复的可靠预案。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;section-22&quot;&gt;预案都需要真正演练过，以证明可行、可靠&lt;/h4&gt;
  &lt;hr /&gt;
&lt;/blockquote&gt;

&lt;p&gt;很多平台在发展初期，或多或少存在一些单点的风险。对这些高风险单点，需要单独加入一个风险关注清单，进行重点关注。并且制定一个逐步消除这类风险的中期时间表。&lt;/p&gt;

&lt;h2 id=&quot;section-23&quot;&gt;四 安全体系建设的日常工作策略&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;系统思考风险及优先级、建立风险应对和控制策略&lt;/li&gt;
  &lt;li&gt;不断从风险清单中整理出阶段任务清单，纳入工作计划&lt;/li&gt;
  &lt;li&gt;从团队建设层面的工作推动&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-24&quot;&gt;4.1 部分典型风险和风控工作建议&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;用户风险&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;风险类型&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;典型风险&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;风控内容及建议&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;关键信息泄漏&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;基本防护薄弱&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;从基本防护角度进行排查，保证通讯链路，APP端无明显泄漏&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;交易风险&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;账户被盗&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;建立找回机制和强行密码重置。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;交易风险&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;伪冒或交易抵赖&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;可追溯机制＋（运营）核查分析机制＋（运营）自证和赔付。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;卖家风险&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;风险类型&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;典型风险&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;风控内容及建议&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;交易风险&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;交易抵赖&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;可追溯机制＋（运营）核查分析机制＋（运营）自证和赔付。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;操作风险&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;误操作&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对关键后台管理操作除了可追溯机制，对关键操作内容要加入（版本和备份策略）。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;法律合规风险&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;风险类型&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;典型风险&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;风控内容及建议&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;商家交易风险&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;商品违规，套现／洗钱风险&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;（从法律和运营角度需要有所预防）。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;平台内部风险&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;风险类型&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;典型风险&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;风控内容及建议&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;人为信息泄漏&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;制度漏洞及权限管理松懈&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;保密制度＋生产数据库操作权限管理 +涉密内容的加密策略。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;网站安全漏洞&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;攻击/恶意篡改&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;建立基本攻防体系，细化日常工作运维审计。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-25&quot;&gt;4.2 安全相关的阶段性工作任务分解 【举例】&lt;/h3&gt;

&lt;h4 id=&quot;section-26&quot;&gt;§ 提升可测试性&lt;/h4&gt;
&lt;p&gt;－ 调研影响测试效率和测试效果的关键薄弱点。 &lt;br /&gt;
－ 着重在测试生产力工具上进行储备和改善。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考方案／文献&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://mqc.aliyun.com/security.htm&quot;&gt;阿里云测&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.jianshu.com/p/70ac552a797e&quot;&gt;Android APP mock测试索引&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.infoq.com/cn/articles/comparison-and-analysis-of-mobile-app-cloud-test-platform&quot;&gt;APP云测试平台比较&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;traceability&quot;&gt;§ 提高事件追溯能力    Traceability&lt;/h4&gt;
&lt;p&gt;－ 搭建统一的日志利用平台&lt;br /&gt;
－ 梳理需要追溯的流程事务、并明确粒度度和准确度准则  &lt;br /&gt;
－ 设定合适生产环境的日志的规范&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考方案／文献&lt;/strong&gt; &lt;br /&gt;
&lt;a href=&quot;http://www.jianshu.com/p/01b7cacfe202&quot;&gt;日志规范实践&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://testing.googleblog.com/2013/06/optimal-logging.html&quot;&gt;Optimal Logging&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-27&quot;&gt;§ 改善安全性&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;根据成熟的安全体系框架，确定每层的现阶段重点工作&lt;/li&gt;
  &lt;li&gt;系统安全层面：密码安全｜服务器漏洞｜内部信息安全防控｜常见攻击的防护能力｜审计制度&lt;/li&gt;
  &lt;li&gt;身份认证/证书： 认证｜证书安全｜认证过程安全&lt;/li&gt;
  &lt;li&gt;风险行为防控：恶意订单｜恶意注册 ｜验证码安全&lt;/li&gt;
  &lt;li&gt;风险策略制定：权限等级｜风险预案｜安全等级｜审计制度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;参考方案／文献&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.fmi.com.cn/index.php?m=content&amp;amp;c=index&amp;amp;a=show&amp;amp;catid=9&amp;amp;id=590845&quot;&gt;“互联网+”环境下信息安全的挑战与机遇&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;http://www.cas.stc.sh.cn/jsjyup/pdf/2013/9/%BB%F9%D3%DAWPKI%B5%C4%D2%C6%B6%AF%B5%E7%D7%D3%C9%CC%CE%F1%B0%B2%C8%AB%D1%D0%BE%BF.pdf&quot;&gt;基于WPKI的移动电子商务安全研究&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://op.baidu.com/2015/04/https-s01a01/&quot;&gt;大型网站的 HTTPS 实践&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-28&quot;&gt;§ 提升监控／告警的能力&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;整理监控点，整理告警策略表&lt;/li&gt;
  &lt;li&gt;确定监控和补强策略（自建｜采购）。&lt;/li&gt;
  &lt;li&gt;验证监控和告警的有效性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;参考方案／文献&lt;/strong&gt;  &lt;br /&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Application_performance_management&quot;&gt;Application performance management&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-29&quot;&gt;§ 团队建设方面&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在团队内进行培训和宣讲，建立全员的安全意识&lt;/li&gt;
  &lt;li&gt;推动跨部门、团队的协调和联动机制的建立。&lt;/li&gt;
  &lt;li&gt;逐步建立制度，优先降低高风险的操作行为｛代码｜发布｜线上操作｜…｝等&lt;/li&gt;
  &lt;li&gt;在需求完善的工作中，加入非功能性需求的补全。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;*&lt;end&gt;*&lt;/end&gt;&lt;/p&gt;</content><author><name>Ryan Wang (Haide1977)</name><email>haide1977 AT gmail.com</email></author><category term="架构" /><category term="互联网" /><category term="基础系统" /><category term="安全" /><summary type="html">现在互联网的新生平台比以往面临着更复杂的技术环境。平台一上线，即面临着全方位、体系性的安全风险考验。以如下几方面情况的引入，可能衍生的安全风险尤为突出：


  面向多种类型端的用户APP产品入口的推出
  更加复杂的用户权益账户、储值类电子账户的引入， 如 积分、内置钱包等
  平台自有的多个支付渠道和多类型收付交易行为的引入， 如 三方支付、交易中途改变支付方式等
  更加复杂的结算和清算场景 ， 如 用户奖励提现，外部积分互换等
  更加复杂的业务和个性化的促销策略， 如 折扣策略、优惠券和羊毛党等
  以及，快速的业务场景和功能的演进。</summary></entry><entry><title type="html">JSR 133 FAQ的翻译和扩展（5）—— volatile相关</title><link href="http://0.0.0.0:4000/2016/06/19/JSR_133_FAQ_Trans_and_Ext_P2_Volatile_do.html" rel="alternate" type="text/html" title="JSR 133 FAQ的翻译和扩展（5）—— volatile相关" /><published>2016-06-19T00:00:00+08:00</published><updated>2016-06-19T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2016/06/19/JSR_133_FAQ_Trans_and_Ext_P2_Volatile_do</id><content type="html" xml:base="http://0.0.0.0:4000/2016/06/19/JSR_133_FAQ_Trans_and_Ext_P2_Volatile_do.html">&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;valotile 关键字对很多 java 开发人员来说并不陌生。 但，也许因为它看上去过于简单，便有了一些似是而非的认识。&lt;/p&gt;

&lt;p&gt;本部分，从FAQ中的 “What does volatile do ” 问题开始，聊一聊 volatile 的能做和不能做的事情以及在并发编程中的相关主题。&lt;br /&gt;
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;volatile&quot;&gt;▸volatile是用来做什么的？【译】&lt;/h2&gt;

&lt;p&gt;[原文]&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#volatile&quot;&gt;What does volatile do ?&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注1：本段在2018年初，重新进行了修订。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;volatile 字段是用来线程间状态通信（ communicating state ）的特殊字段。每次对一个 volatile 字段的读取都可看到其它线程对这个字段的写入（的最新值）；实际上，它们是编程人员设定用来保证不接收 “ 过期 ” （ stale ）值的。这些过期值可能是重排序或者缓存的结果。编译器和运行时会被禁止把它们分配入寄存器。同样，它们也必须确保在被改写后，被从缓存中刷新到主存，以便可以让它们被其它线程立即可见。类似的，在一个 volatile 字段被读取之前，缓存必须先失效，以保证读取到的值是来自主存，而不是在本地处理器缓存。在重排序访问 volatie 变量时，也会有一些额外的限制。&lt;/p&gt;

&lt;p&gt;在旧的内存模型里，对几个 volatile 变量的访问不能相互间重排序，但是它们可以与 &lt;strong&gt;非 volatile （ nonvolatile ）&lt;/strong&gt;变量的访问顺序进行重排序。这就削弱了 volatile 字段作为线程间信号条件（ signaling conditions ）手段的作用。 &lt;br /&gt;
 &lt;br /&gt;
在新的内存模型中，对几个 volatile 变量的访问依旧不能相互间重排序。差别是，对它们周围的普通字段的访问，也不再那么容易重排序了。写入一个 volatile 字段，会有监视器释放（ monitor release ）相同的内存效果，而读取一个 volatile 字段，则有监视器获取（ monitor acquire ）同样的内存效果。实际上，因为新的内存模型设置了对 volatile 字段访问和其它类型字段访问的更加严格的重排序限制，无论（字段） volatile 与否，任何线程 A 在写入 volatile 字段 f 时可见的（周围）字段，对于线程 B 在读取 f 时候，都会变成可见。   &lt;br /&gt;
 &lt;br /&gt;
下面的简单例子展现了 volatile 字段怎么使用：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;VolatileExample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
  &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
      &lt;span class=&quot;c1&quot;&gt;//uses x - guaranteed to see 42. &lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;假设有个线程正在调用 “writer()” 方法，而另一个正在调用 “reader()” 方法。则，在 writer 中对 v 的写入时， x 的写入也会被释放 （ release ）到内存，因而对 v 的读取，可以从内存中获取 (acquire) 该值。这样，如果可以在 “reader()” 中看到 v 的 true 值，也可确保之前对 x 写入的值 42 可见。在旧的内存模型中，情况未必会这样。（旧模型中）如果 v 不是 volatile 类型，那么编译器可以在 writer() 方法中对写入重排序，这样，在 reader() 方法中，可能会读到 x 的值为 “0” 。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注2：在本系列的第（4）篇中的“构建良好的执行”的例子中，其实更好解释了这一问题。这里有点语焉不详。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对 volatile 类型语义的大幅度增强，几乎使之达到了同步的级别（ the level of synchronization ）。为了可见性的目的，对 volatile 字段的每个读、写，就像扮演了 “ 半 ” 同步的操作。&lt;/p&gt;

&lt;p&gt; 
重要提示：为了正确地建立前序（ happens-before ）关系，重要的一点是要让所有线程访问相同的 volatile 变量。否则，诸如当线程 A 写入的是 volatile 字段 f ，而在线程 B 读取的却是 volatile 字段 g ，那么所有的可见情况，未必会如预期。 释放（ Release ）和 获取（ acquire ）必须要 “ 匹配（ match ） ” （比如：要针对同一个 volatile 字段），以获得正确的语义。&lt;/p&gt;

&lt;h2 id=&quot;volatile-&quot;&gt;volatile 能做和不能做的&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;volatile 可以保证可见性，即 每次读取时都从主存中读，每次修改时，都将修改后的值重新写入了主存。&lt;/li&gt;
  &lt;li&gt;volatile 可以防止了容易产生超出预期结果的指令重排序，这个影响可以扩散到程序顺序中前序的指令。【具体可参见 本系列第 (4) 篇】。&lt;/li&gt;
  &lt;li&gt;volatile 不能保证原子性（所以，不能用做多线程下的计数器）。&lt;/li&gt;
  &lt;li&gt;凡事都有代价。volatile 防止一部分指令重排序的特性，削弱了JVM中的运行时优化，同时强制的缓存刷新和失效的操作，都会降低运行效率。 所以不要过度使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;volatile--1&quot;&gt;volatile 的用与不用&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;不适合的场景&lt;/h3&gt;
&lt;p&gt;1.常量（ final ）字段 &lt;strong&gt;不能&lt;/strong&gt;用 volatile 修饰，否则会编译出错。&lt;/p&gt;

&lt;p&gt;2.只有单线程访问的变量，&lt;strong&gt;不需要&lt;/strong&gt;用 volatile 来保证可见（好像有点废话 ）。&lt;/p&gt;

&lt;p&gt;3.存在复杂的 “锁” 的操作需求的场景（比如对变量值修改期间，要阻止读取——即，读取值锁定），&lt;strong&gt;不适合&lt;/strong&gt; 用 volatile 来实现。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;适合的场景&lt;/h3&gt;
&lt;p&gt;作为类似 “信号量” 变量 来使用，保证每个线程都可以看到当前的最新“信号”标志，且信号值的改变与当前值无关，并且不关心改变的历史量。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;但，如果需要管理大量类似的 “信号量” ，使用 java.util.concurrent 包中的一些数据结构，显然是效率和性能更好的选择。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;go--volatile&quot;&gt;为什么 GO 语言中没有 volatile&lt;/h2&gt;
&lt;p&gt;“Do not communicate by sharing memory; instead, share memory by communicating.” 这句“ 名言 ”，很好的概括了这一设计思想。&lt;sup id=&quot;fnref:GoComm&quot;&gt;&lt;a href=&quot;#fn:GoComm&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&quot;volatile---atomic-&quot;&gt;volatile 和  Atomic 类型变量&lt;/h2&gt;
&lt;p&gt;2004年，就在这篇 FAQ 发布后的半年后，JDK1.5 （JDK5 ）也发布了。JDK5 包含了全新
的并发工具包，就是大家熟知的 &lt;strong&gt;java.util.concurrent&lt;/strong&gt; 包。 concurrent 包很大程度
地简化了并发应用的开发，后续影响深远。其中包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Executor 执行框架&lt;/strong&gt;，更好的管理线程池的方式。（较之于很多人自己手动管理多线程任务，
  可能更稳定，也能更好的管理资源的消耗。）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;更好支持并发的集合类型&lt;/strong&gt;，比如 &lt;strong&gt;BlockingQueue（ 阻塞队列 ）接口&lt;/strong&gt;，&lt;strong&gt;ConcurrentMap 接口&lt;/strong&gt;及引用此接口的 &lt;strong&gt;ConcurrentHashMap类&lt;/strong&gt; 等。（后续的版本里，这部分集合被持续的丰富了。也是很多面试官的考题来源）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Atomic 工具类&lt;/strong&gt;，提供了无锁（lock-free）、线程安全（thread-safe）的变量操作。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Atomic类型是对volatile修饰的进一步扩展&lt;/strong&gt; ，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;（对Atomic 变量的）&lt;em&gt;get&lt;/em&gt; 操作（如：incrementAndGet ）等同于对一个 &lt;em&gt;volatile&lt;/em&gt;变量的读取（等同的内存操作效果）。 类似的，&lt;em&gt;set&lt;/em&gt; 操作，相当于对一个 &lt;em&gt;volatile&lt;/em&gt; 的写入效果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;weakCompareAndSet 操作，相当于先进行了一次 Atomic读取，然后再决定是否写入。但是这个过程不与周边代码形成强的“ happen-before（先序）”，所以只确保本身的可见性，不会确保周边变量的可见性。【关于这一点，之前的几篇的篇幅里，有例子提到过】&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JDK 1.6 以后，又引入了lazyset&lt;sup id=&quot;fnref:LazySet&quot;&gt;&lt;a href=&quot;#fn:LazySet&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。典型场景是应用在垃圾收集时，清零（nulling out ）一个永远不会再次访问的引用。采用的是 store-store 的内存栅栏方式，即保证这个写入能在后续其他的写入前，被其他线程可见。&lt;sup id=&quot;fnref:Store-Store&quot;&gt;&lt;a href=&quot;#fn:Store-Store&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; .&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Atomic 使原本非线程安全的数组（Array ），具有了线程安全的替代（AtomicLongArray ）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;volatile 是个相当古老的编程语言关键词了。有不少经典的文章,如 &lt;em&gt;volatile vs. volatile&lt;/em&gt;&lt;sup id=&quot;fnref:VvsV&quot;&gt;&lt;a href=&quot;#fn:VvsV&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;。今天来聊这个话题，似乎显得有点过时。 也可以预见，对它的运用也会逐渐的淡出。&lt;/p&gt;

&lt;p&gt;不过，深入到底层，我们还是可以发现，原理性的东西，其实并没有想象中的变化那么大————较之于眼花缭乱的时髦新技术名词而言————依然有助于我们理解和思考并发状态下的一些问题。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;&lt;strong&gt;其他参考链接&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;-&lt;a href=&quot;https://stackoverflow.com/questions/1468007/atomicinteger-lazyset-vs-set&quot;&gt;Stack overflow:atomicinteger-lazyset-vs-set&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;-&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/essential/concurrency/highlevel.html&quot;&gt;Oracle:High Level Concurrency Objects&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;-&lt;a href=&quot;https://www.classes.cs.uchicago.edu/archive/2013/spring/12300-1/labs/lab6/&quot;&gt;Concurrency in C++11&lt;/a&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;section-5&quot;&gt;&lt;strong&gt;参考索引&lt;/strong&gt;&lt;/h2&gt;

&lt;end&gt;

&lt;/end&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:GoComm&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.golang.org/share-memory-by-communicating&quot;&gt;Go Blog :Share Memory By Communicating &lt;/a&gt; &lt;a href=&quot;#fnref:GoComm&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:LazySet&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6275329&quot;&gt;JDK-6275329 : Add lazySet methods to atomic classes&lt;/a&gt; &lt;a href=&quot;#fnref:LazySet&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:Store-Store&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://dreamrunner.org/blog/2014/07/05/multithreadingxiang-guan-zhu-yu-zong-jie/&quot;&gt;Multithreading相关术语总结&lt;/a&gt; &lt;a href=&quot;#fnref:Store-Store&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:VvsV&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.drdobbs.com/parallel/volatile-vs-volatile/212701484?pgno=1&quot;&gt;volatile vs. volatile&lt;/a&gt; &lt;a href=&quot;#fnref:VvsV&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Ryan Wang (Haide1977)</name><email>haide1977 AT gmail.com</email></author><category term="架构" /><category term="并发与并行" /><category term="开发语言" /><summary type="html">前言
valotile 关键字对很多 java 开发人员来说并不陌生。 但，也许因为它看上去过于简单，便有了一些似是而非的认识。

本部分，从FAQ中的 “What does volatile do ” 问题开始，聊一聊 volatile 的能做和不能做的事情以及在并发编程中的相关主题。</summary></entry><entry><title type="html">JSR 133 FAQ的翻译和扩展（4）—— 关键定义（二）</title><link href="http://0.0.0.0:4000/2016/05/28/JSR_133_FAQ_Trans_and_Ext_P4_chp17-2.html" rel="alternate" type="text/html" title="JSR 133 FAQ的翻译和扩展（4）—— 关键定义（二）" /><published>2016-05-28T00:00:00+08:00</published><updated>2016-05-28T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2016/05/28/JSR_133_FAQ_Trans_and_Ext_P4_chp17-2</id><content type="html" xml:base="http://0.0.0.0:4000/2016/05/28/JSR_133_FAQ_Trans_and_Ext_P4_chp17-2.html">&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;本篇，着重结合 JSR 133 FAQ 中的同步相关 FAQ ，以及JSR 133 中的其余的关键定义，围绕同步 sychronization ，happen before 等进行展开。 &lt;br /&gt;
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;▸ 不正确的同步意味着什么？【译】&lt;/h2&gt;

&lt;p&gt;[原文]&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#incorrectlySync&quot;&gt;What do you mean by “incorrectly synchronized”? &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不正确的同步处理代码（ incorrectly synchronized code ），对不同的人有着不同含义。 当我们在 java 内存模型语义下讨论不正确的同步代码时，是指任何代码中出现了以下现象：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;有某个线程对某个变量有写操作，&lt;/li&gt;
  &lt;li&gt;另一个线程对同一个变量有读操作，&lt;/li&gt;
  &lt;li&gt;且，读和写没有通过同步来实现有序。 
 
当有这些规则被违背的时候，我们就说存在对于这个变量的数据竞争（ data race ）。一个有数据竞争的程序，就是不正确地同步的程序。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;▸ 同步会做些什么？【译】&lt;/h2&gt;
&lt;p&gt;[原文]&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#synchronization&quot;&gt;What does synchronization do? &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;同步（ Synchronization ）包括若干个方面。最广为人知的是互斥（ mutual exclusion ） —— 即，只有一个线程在某个时刻拥有监视器（ monitor，或译作管程  ）&lt;sup id=&quot;fnref:Monitor&quot;&gt;&lt;a href=&quot;#fn:Monitor&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，所以，基于监视器的同步行为意味着一旦一个线程进入了被监视器保护的同步块（ synchronized block ），在这个线程退出前，没有任何其它线程再可以进入被这个监视器保护的块。     &lt;br /&gt;
 &lt;br /&gt;
但是，同步还有 “ 互斥 “ 之外的更多含义。在基于同一个的同步监视器的前提下，同步确保了一块内存被一个线程写入前或写入中，该同步块对于其它线程的可见过程是处于可预测的状态下。当我们 &lt;strong&gt;退出&lt;/strong&gt;（ exit ）同步块，我们通过 &lt;strong&gt;释放&lt;/strong&gt;（ release ）监视器来达到 &lt;strong&gt;刷新&lt;/strong&gt;（ flushing ）缓存数据到主存的效果，从而使本线程完成的写入能够对其它线程可见。在我们能 &lt;strong&gt;进入&lt;/strong&gt;（ enter ）同步块之前，我们通过 &lt;strong&gt;获取&lt;/strong&gt;（ acquire ）监视器来达到使本地处理器缓存失效，让变量重新从主存中 &lt;strong&gt;载入&lt;/strong&gt;（ reloaded ）的效果。这样，我们就可以看到由之前的（其他线程的） &lt;strong&gt;释放&lt;/strong&gt;（ release) 涉及到的所有写入。   &lt;br /&gt;
 &lt;br /&gt;
从缓存的角度讨论这个话题，似乎听起来这些问题只影响到多处理器机器（ multiprocessor machines ）。然而，重排序效果其实也可以很容易在单处理器（ single processor ）上见到。例如，让编译器在 &lt;strong&gt;获取&lt;/strong&gt; 前，或者在 &lt;strong&gt;释放&lt;/strong&gt;后去移动你的代码（ code ）是不可能的。 当我们谈到缓存的 &lt;strong&gt;获取&lt;/strong&gt;和 &lt;strong&gt;释放&lt;/strong&gt;动作时，我们简略掉了其中大量的可能影响。 &lt;br /&gt;
 
新内存模型创建了对于内存操作行为（读字段 read field ，写字段 write field ，锁 lock ，解锁 unlock ）和其它线程操作行为（开始 start ，阻塞等待 join 【翻译注：参见 官方文档中线程行为的表述&lt;sup id=&quot;fnref:ConJoin&quot;&gt;&lt;a href=&quot;#fn:ConJoin&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; 】）等实现部分有序的语义：即，要求某些操作，比其他一些操作要 &lt;strong&gt;“先于发生”（ happen before ）&lt;/strong&gt;。如果一个行为是发生在另一个之前（ happens before ），那么意味着第一个是确保在前序发生（be  ordered before）的且对第二个可见。具体的有序规则如下：&lt;/p&gt;

&lt;p&gt;∙ 在一个线程中的每个动作（ action ），都要比该线程中，按代码顺序（ program order ）的每一个后续动作先发生 &lt;strong&gt;“先于发生”（ happen before ）&lt;/strong&gt;。 &lt;br /&gt;
  ∙ 对一个监视器的解锁（ unlock ）动作 ，要比&lt;strong&gt;该监视器&lt;/strong&gt;的每一个后续锁（ lock ）动作 ** “先于发生”（ happen before ）&lt;strong&gt;。 &lt;br /&gt;
  ∙ 对于一个可变( volatile )字段的 **写&lt;/strong&gt;操作 ，都要比&lt;strong&gt;该变量&lt;/strong&gt;的每一个后续&lt;strong&gt;读&lt;/strong&gt;操作  ** “先于发生”（ happen before ）&lt;strong&gt;。 &lt;br /&gt;
  ∙ 对于某个线程的 start() 方法调用，都要比&lt;/strong&gt;该线程&lt;strong&gt;启动后的任何动作先发生。   &lt;br /&gt;
  ∙ 对于某个线程中的所有动作，都要比其它任何线程调用 join() 方法阻塞等待从这个线程返回&lt;/strong&gt; “先于发生”（ happen before ）&lt;strong&gt;。   &lt;br /&gt;
 &lt;br /&gt;
这就意味着，在同一个监视器保护的同步块，对于某个线程在退出同步块前可见的任何内存操作，对于后续进入同步块的其它任何线程也是可见的。因为，所有的内存操作比释放（ release ）行为 **“先于发生”（ happen before ）&lt;/strong&gt;，所有释放（ release ）行为比获取（ acquire ）行为 &lt;strong&gt;“先于发生”（ happen before ）&lt;/strong&gt;   &lt;br /&gt;
 &lt;br /&gt;
  &amp;gt;【翻译注：为更简洁和符合中文习惯，happen - before ，在后文部分中文句式中，我简称为 “前序” 关系】 。&lt;/p&gt;

&lt;p&gt;另有一层含义是，像下面这样，有些人通常用来进行强制内存隔离的模式，实际是无效的：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;   
  synchronized (new Object()) {} 
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这实际上是一个空操作，编译器可以把它完全移除，因为它知道没有其它线程会基于这个监视器同步。你必须为线程建立好&lt;strong&gt;“ 前序 （happen - before）”&lt;/strong&gt; 关系，才能使一个线程（正确地）看到其它线程的操作结果。   &lt;br /&gt;
 &lt;br /&gt;
&lt;strong&gt;重要提示：&lt;/strong&gt; 为了建立恰当的 &lt;strong&gt;“ 前序 ”&lt;/strong&gt; 关系，很重要的一点，是要让线程同步在 &lt;strong&gt;同一个监视器&lt;/strong&gt;上。 A 线程同步在对象 X 时的所有可见，不会变成线程 B 之后对对象 Y 的可见。释放（ release ）和获取（ acquire ）必须相 匹配（例如，基于同一个监视器），来确保正确的语义。否则，代码就会有数据竞争（ data race ） 。&lt;/p&gt;

&lt;h2 id=&quot;jsr-133&quot;&gt;JSR 133中的关键定义（二）&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;说明：JSR 133 的第 5 部分 Definations 中的第一部分概念，已在系列（3）中涉及。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在继续往下前聊JSR133 （JSR133中英文原文链接 &lt;sup id=&quot;fnref:JSR133&quot;&gt;&lt;a href=&quot;#fn:JSR133&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&quot;fnref:JSR133cn&quot;&gt;&lt;a href=&quot;#fn:JSR133cn&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; ） 相关内容前，有必要再来聊一下顺序一致模型。理论上来说，只要有一个全局优化器，就可以实现顺序一致执行了。同时也可以很大程度简化代码编写的复杂度。但，实际上，无论是对硬件还是运行时（runtimes），都很难有这样的全局优化器。原因显而易见。一个较之弱化的模型，不是对全局，而是只对部分特殊的行为来有序。&lt;/p&gt;

&lt;h3 id=&quot;pososwhb&quot;&gt;1. po、so、sw和hb&lt;/h3&gt;
&lt;p&gt;从开发层面去了解Java 内存模型的动作行为，实际是理解以下四个行为的逻辑：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;程序顺序&lt;/strong&gt; (Program Order ）—— “关键定义（一）“中已经说明， &lt;script type=&quot;math/tex&quot;&gt;\xrightarrow{\text{ po }}&lt;/script&gt;   &lt;br /&gt;
这里需要重点强调是：从线程间动作的视角看，程序顺序不能也不会提供任何重排序的保证，它只是代表了最终执行和原始代码之间的关联。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;同步顺序&lt;/strong&gt;（Sychronization Order），&lt;script type=&quot;math/tex&quot;&gt;\xrightarrow{\text{ so }}&lt;/script&gt;  &lt;br /&gt;
在某一次执行中，所有同步动作的完整执行顺序 。 从单线程的角度看，同步顺序 （so) 和 程序顺序 （ po ）是一致的。在同步顺序中的所有的“读” 都能看到最新的 “写” 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Sychronizes-With 边界&lt;/strong&gt;（Sychronization-With edges），&lt;script type=&quot;math/tex&quot;&gt;\xrightarrow{\text{ sw }}&lt;/script&gt; &lt;br /&gt;
 每个同步动作的起始点或者结束点，就是动作的“Sychronizes-With “ edges （同步动作间的边界）。&lt;br /&gt;
 如公式示意：&lt;br /&gt;
 &lt;script type=&quot;math/tex&quot;&gt;\ release(m) \xrightarrow{\text{ sw }}  acquire(m)&lt;/script&gt;   ，“Sychronizes-With “ 边界的起点是同步动作的结束（ release ） ，终点是同步动作的开始 （ acquire ）。 &lt;br /&gt;
   &lt;strong&gt;【注：是同步动作引出了 “ Sychronizes-With “ 关系，从而形成了同步顺序。而不是相反  】&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;“前序”&lt;/strong&gt;关系 （Happen - before ），&lt;script type=&quot;math/tex&quot;&gt;\xrightarrow{\text{ hb }}&lt;/script&gt;  &lt;br /&gt;
同步顺序中的前序关系的发生是由 程序顺序与“ Sychronizes-With “ 关系共同作用的结果。&lt;br /&gt;
**但是有前序关系，不等于执行就会按照这个关系进行重排序 ** 。&lt;br /&gt;
∙ 如果 &lt;script type=&quot;math/tex&quot;&gt;\ x \xrightarrow{\text{ sw }}  y&lt;/script&gt; （即，动作 x 和后续的动作 y 有“ Sychronizes-With “ 关系） ,那么，也意味着 &lt;script type=&quot;math/tex&quot;&gt;\ x \xrightarrow{\text{ hb }}  y&lt;/script&gt; 关系的存在 。&lt;/p&gt;

    &lt;p&gt;∙ &lt;script type=&quot;math/tex&quot;&gt;\xrightarrow{\text{ hb }}&lt;/script&gt;  属于偏序关系&lt;sup id=&quot;fnref:PartOrd&quot;&gt;&lt;a href=&quot;#fn:PartOrd&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;，具有自反性，传递性和非对称性的特征。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来，我们就从这几个定义出发来进一步理解内存模型。&lt;/p&gt;

&lt;h3 id=&quot;actions-and-executions-&quot;&gt;2.动作和执行( Actions and Executions )&lt;/h3&gt;

&lt;p&gt;内存模型的一个作用，就是为了构建良好（ well- formed  ）的执行。所以，这里先要定义一下执行。一个执行E可以用元组&amp;lt; P,A,po,so,W,V,sw,hb&amp;gt; 来描述&lt;sup id=&quot;fnref:ExeTurp&quot;&gt;&lt;a href=&quot;#fn:ExeTurp&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt; 。出了前文提到的 po,so,sw,hb 四种行为逻辑之外，
还包括：&lt;br /&gt;
    ∙ P - 程序 。&lt;br /&gt;
    ∙ A - 一组动作 。 可以用 &amp;lt;t,k,v,u&amp;gt; 元组，即&amp;lt;执行线程，动作类型（前面已经表述），变量／监视器，唯一标识符&amp;gt;来定义。     &lt;br /&gt;
    ∙ W - “写-可见”（ write-seen ）函数 。对于 A 中的每个读操作 r，W(r) 代表在执行 E 中对 r 可见的写。  &lt;br /&gt;
    ∙ V - “值写入”（ value-written ）函数。对于 A 中的每个读操作 w，V(w)代表在执行 E 中 w写入的值 。&lt;/p&gt;

&lt;p&gt;本文并没有计划重复和深入相关的数学推导，这里强调元组定义的目的，只是为了帮助后续讨论建立完整概貌。&lt;/p&gt;

&lt;h3 id=&quot;well-formed-executions-&quot;&gt;3.构建良好的执行( Well-Formed Executions )&lt;/h3&gt;

&lt;p&gt;终于离问题的目标越来越接近了。前面的所有的铺垫和解释，现在到了一个思考的聚焦点： &lt;br /&gt;
E=&amp;lt; P,A,po,so,W,V,sw,hb&amp;gt;。  现在的问题是，如果有一段程序摆在我们面前，我们如何合理的推断出一个正确、无二义的执行计划 E 。
不太确切的说，最后的 E 是元组中不同元素的相互约束，制约的结果，从多组可能的候选执行计划中，选出满足各个约束的最终交集。&lt;/p&gt;

&lt;p&gt;我们还是先直接跳到结论吧。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://postimg.cc/tZy7s0Ds&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/rmR4YMrN/20160528eplan.png&quot; alt=&quot;执行的生成&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;除了上图已经明确表达的约束。构建良好的执行【JSR133 §7.3 以及 JLS § 17.4.7 】也包括对 W ，V 的约束。即，对与volatile的变量的写都要确保每个读取的可见。但这并不以意味着对 &lt;script type=&quot;math/tex&quot;&gt;\xrightarrow{\text{ so }}&lt;/script&gt; 约束要求的放松。因为，这里的每个读取可见的实质含义是每次的写都被刷新到了主存中，以便读取的不是过期的值。但是，如果有没有同步序 so 的约束，不能互斥。&lt;/p&gt;

&lt;p&gt;举个直观的例子来说明下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;VSC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
   
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;如上例： 
    ∙  set（） 方法前的，synchronized 修饰仍是需要的，否则不能实现互斥，保证 val 只被设置一次。
    ∙  另一方面，如果 val 前没有 volatile 修饰，在保持代码其他部分不变的情况下，在几个线程的 同步边界间（ sw ）发生的 val 的写入的值 ，未必一定对另一个线程可见。 &lt;br /&gt;
    ∙  get（）方法前， 加上 synchronized 的修饰 在这个场景下 &lt;strong&gt;不是必须&lt;/strong&gt; 的。除了增加系统瓶颈外（因为读的线程数可能远远超过写的），没有额外作用。&lt;/p&gt;

&lt;p&gt;关于基于因果关系的可提交【 JSR133 §7.3 】的9条原则，以及 其中的一些测试例子，这里不打算再展开。因为，从开发角度来说，我们还是更关心，按照怎么样的语法和语义，可以让程序按照我们期望的方式运行。而不是相反的：如果不加以约束，JIT 编译器和运行时会有多少种可能的运行。这个问题，显然复杂的多，而且也更适合像 JVM 虚拟机编写等岗位去研究。&lt;/p&gt;

&lt;p&gt;所以，抛开可提交这个约束 ，构建良好的执行需要满足如下条件【JLS §17.4.7】&lt;sup id=&quot;fnref:ExeWell&quot;&gt;&lt;a href=&quot;#fn:ExeWell&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;对于 volatile 变量，每个读都可以看到对这个变量的写的值 v。&lt;/strong&gt;  即，W(r).v =r.v 。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;hb （通过 po 和 sw 传递构成）是偏序关系 。&lt;/strong&gt; 即，符合偏序的自反、传递和反对称三个特性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;遵循线程内一致性（Intra-Thread Consistency）。&lt;/strong&gt; 即 P 的执行遵循线程内语义。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;执行满足 hb 一致性 （ happens-before consistent ）。&lt;/strong&gt;  即，对于任何变量的读操作，不存在 hb(r, W(r))  ；也不存在满足 w.v = r.v ， hb(W(r), w) 和 hb(w, r) 的 w 。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;执行满足 so 一致性 。&lt;/strong&gt; 即对于所有volatile变量的读操作，不存在 so(r, W(r))  ；也不存在满足 w.v = r.v ， so(W(r), w) 和 so(w, r) 的 w 。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-3&quot;&gt;4.理解代码的执行结构。&lt;/h3&gt;

&lt;p&gt;以及涉及到了相对抽象的概念和定义（当然 JSR133 原文中还要更多）。接下来，我要说一下从我的理解角度，怎么比较快速的理解代码的在多线程状态下的执行结构（包括执行结果）————暂时仅围绕本章已经涉及的概念。&lt;/p&gt;

&lt;p&gt;∙ 如果没有 volatile 修饰的 变量。我们先可以假设在不违背单线程语义的情况下，一切的重排序都是有可能的。&lt;/p&gt;

&lt;p&gt;∙ 如果有 volatile 修饰的变量，我们要先找到这些变量在多线程间的 release - acquire 关系，找到关键的 sw 关系，并结合 sw 前后代码序的，分析可见的影响范围。&lt;/p&gt;

&lt;p&gt;∙ 对第2点，关于写入的可见问题。我们可以认为，如果 volatile 变量可见了，按照代码序po “前序”的变量也对其他线程可见了。 在该代码序之后的写入，可能可见（不排除重排序）。&lt;/p&gt;

&lt;p&gt;∙ Synchronized 修饰的存在，意味着互斥（锁）的存在。 按照互斥隔离的思路考虑执行结果。&lt;/p&gt;

&lt;p&gt;举个例子来说明上述的的理解：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://postimg.cc/hXgP99L5&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/g2LXbsnm/20160528vsc.png&quot; alt=&quot;happen - before相关 &quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如上例：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在 ready 变量有 volatile 修饰的情况下，对 &lt;code class=&quot;highlighter-rouge&quot;&gt;ready = true&lt;/code&gt;的写，和&lt;code class=&quot;highlighter-rouge&quot;&gt;ready == true&lt;/code&gt; 之间形成了 sw （同步边界）关系。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同时 ，由于 po关系 ，&lt;code class=&quot;highlighter-rouge&quot;&gt;a=12&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;ready = true&lt;/code&gt;  形成了 hb （先序）关系。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;又，a 变量，由于没有其他特定修饰，很有概率&lt;code class=&quot;highlighter-rouge&quot;&gt;a=13&lt;/code&gt; 在执行时被重排序。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;综上，Thread - 2 和 Thread - 3 会打印 12 或者13 。这两个线程输出的结果可能相同也可能不同。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;4.假设：ready 变量去掉 volatile 修饰。那么， 线程间实际上失去了明确的同步边界。也就意味着在不做执行顺序的假设的情况，任何执行结果都有可能，即，打印出0、11、12、13的可能。&lt;/p&gt;

&lt;p&gt;5.在实际代码中，这样的线程间关系，也可能很容易制造死锁。需要根据情况加上必要的线程暂停保护,如 sleep(）.&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;本篇小结&lt;/h2&gt;
&lt;p&gt;至此，除了更偏底层的理论，已经把内存模型的来龙去脉、主要概念和总体结构做了相对完整的全貌的整理复述。&lt;br /&gt;
   而在JSR 133 FAQ中的问题中，主要就剩下 volatile 和 final 字段相关的了。由于 final 语义的问题，更多是出在内存模型本身的问题——一般开发者对其运用并无太多疑问。而 volatile 在实际开发运用中，经常有些似是而非的理解，所以，下一篇，将重点关注这部分内容。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;参考索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;*&lt;end&gt;*&lt;/end&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:Monitor&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/監視器_(程序同步化)&quot;&gt;wiki 监视器（管程）&lt;/a&gt; &lt;a href=&quot;#fnref:Monitor&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ConJoin&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/essential/concurrency/join.html&quot;&gt;Java官方文档：join操作等 &lt;/a&gt; &lt;a href=&quot;#fnref:ConJoin&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:JSR133&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf&quot;&gt;JSR-133: JavaTM Memory Model and Thread Specification &lt;/a&gt; &lt;a href=&quot;#fnref:JSR133&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:JSR133cn&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://ifeve.com/wp-content/uploads/2014/03/JSR133%E4%B8%AD%E6%96%87%E7%89%881.pdf&quot;&gt;JSR-133 非官方中文翻译 &lt;/a&gt; &lt;a href=&quot;#fnref:JSR133cn&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:PartOrd&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB&quot;&gt;wiki 偏序关系 &lt;/a&gt; &lt;a href=&quot;#fnref:PartOrd&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ExeTurp&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.6&quot;&gt;执行（ Executions ）的定义 &lt;/a&gt; &lt;a href=&quot;#fnref:ExeTurp&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ExeWell&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.7&quot;&gt;well-formed Executions  &lt;/a&gt; &lt;a href=&quot;#fnref:ExeWell&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Ryan Wang (Haide1977)</name><email>haide1977 AT gmail.com</email></author><category term="架构" /><category term="并发与并行" /><category term="开发语言" /><summary type="html">前言

本篇，着重结合 JSR 133 FAQ 中的同步相关 FAQ ，以及JSR 133 中的其余的关键定义，围绕同步 sychronization ，happen before 等进行展开。</summary></entry><entry><title type="html">JSR 133 FAQ的翻译和扩展（3）—— 关键定义（一）</title><link href="http://0.0.0.0:4000/2016/05/14/JSR_133_FAQ_Trans_and_Ext_P3_chp17.html" rel="alternate" type="text/html" title="JSR 133 FAQ的翻译和扩展（3）—— 关键定义（一）" /><published>2016-05-14T00:00:00+08:00</published><updated>2016-05-14T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2016/05/14/JSR_133_FAQ_Trans_and_Ext_P3_chp17</id><content type="html" xml:base="http://0.0.0.0:4000/2016/05/14/JSR_133_FAQ_Trans_and_Ext_P3_chp17.html">&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;如果真正对Java 语言和 JVM 的很多底层细节和原理有兴趣，那么，阅读官方的 Java 语言规范 （&lt;em&gt;The Java Language Specification&lt;/em&gt;  简称 JLS ）和 Java 虚拟机规范 （&lt;em&gt;The Java Virtual Machine Specification&lt;/em&gt;  简称 JVMS ） ，无疑是最有帮助的，也最原汁原味。但是，对于很多研发人员来说，阅读这样的文档，无疑是一种挑战 。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;jsr-133-&quot;&gt;▸JSR 133 是讲什么的？【译】&lt;/h2&gt;

&lt;p&gt;[原文]&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#jsr133&quot;&gt;What is JSR 133 about? &lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;翻译注：&lt;br /&gt;
JSR 133 里的内容和思想，最终是要在 &lt;strong&gt;Java 语言规范&lt;/strong&gt;  和  &lt;strong&gt;Java 虚拟机规范&lt;/strong&gt; 中体现。&lt;sup id=&quot;fnref:JSR133&quot;&gt;&lt;a href=&quot;#fn:JSR133&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1997 年以来，定义在 Java Language  Specification 第 17 章（ Chapter 17 ）的 Java 内存模型已经被发现了一些严重的缺陷（ flaws ）。这些缺陷会允许一些令人困惑的（ confusing ）行为发生 ( 例如 final 字段（ fields ）被发现改变了它们值 ) ，同时也削弱了编译器执行常见优化的能力。   &lt;br /&gt;
 &lt;br /&gt;
Java 内存模型是一个雄心勃勃的尝试；它第一次从一个编程语言规格说明（ specification ）层面来体现一个可以在跨越不同架构时，仍可保持对并发的语义上一致的内存模型。不幸的是，定义一个既能保持一致性，又直观无二义的内存模型，已经被证明要远比想像的更困难。 &lt;br /&gt;
 &lt;br /&gt;
完整的语义表述可参见：http://www.cs.umd.edu/users/pugh/java/memoryModel ,   但是正式的语义不是为小心翼翼者准备的。它以令人吃惊和清醒的方式揭示了像同步这样看上去简单的概念，实际上会多么的复杂。幸运的是，你不需要去了解正式语义中的全部细节 ——JSR133 的目标，是创造一整套正式语义来为 &lt;strong&gt;volatile&lt;/strong&gt; ，&lt;strong&gt;synchronized&lt;/strong&gt; 和 &lt;strong&gt;final&lt;/strong&gt;   的运行提供一套直观无二义的框架。&lt;/p&gt;

&lt;p&gt;具体来说， JSR133 的目标包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;保留已有的安全保障，如，类型安全（ type-safety ），同时强化一些其它保障。例如，变量的值不能无中生有（ out of thin air ）的生成：某个线程能观察（ observed ）到的一个变量的每个值，必须是被其他某线程合理设置的值。&lt;/li&gt;
  &lt;li&gt;正确同步的程序的语义应该尽可能的简单、直观。&lt;/li&gt;
  &lt;li&gt;不完整或者不正确的同步程序的语义，也应该被定义出来，以便把潜在安全威胁降到最低。&lt;/li&gt;
  &lt;li&gt;使编程人员能够确信地推断出多线程的程序是如何与内存进行交互的。&lt;/li&gt;
  &lt;li&gt;使设计出正确、高性能，同时能广泛的跨越多个流行硬件架构的 JVM （具体）实现成为可能。&lt;/li&gt;
  &lt;li&gt;提供一个新的叫做 &lt;strong&gt;初始化安全&lt;/strong&gt; （initialization safety ） 的安全保障。如果一个对象被正确的构建了（即，对它的引用不会在构造期间暴露（ do not escape during construction ）），那么所有对这个对象的引用可见的线程，同样对它在构造器中设定的 &lt;strong&gt;final&lt;/strong&gt; 字段（ final fields ）的值可见，并且，这个过程不需要同步。&lt;/li&gt;
  &lt;li&gt;对已有代码的影响应该最小化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jsr-133&quot;&gt;JSR 133中的关键定义（一）&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;说明：JSR 133 的第 5 部分 Definations 为一些概念做了更详细的定义。这些定义还是偏抽象理论。这部分会结合JLS 和 JVMS 的具体内容来进一步解读。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;shared-variablesheap-memory-&quot;&gt;1. 共享变量／堆内存 (Shared variables/Heap memory ）&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;JSR 133 原文翻译：&lt;br /&gt;
能够在线程间共享的内存被称为 “&lt;strong&gt;共享&lt;/strong&gt;（shared 
）“内存 或者 “&lt;strong&gt;堆&lt;/strong&gt;（Heap ）”内存 。所有的实例字段（instance fields ），静态字段（static fields ）以及数组元素都存储在 &lt;strong&gt;堆&lt;/strong&gt;内存中。(翻译注：为便于表述 ) 我们使用 &lt;strong&gt;变量(variable )&lt;/strong&gt;这个词来表示字段和数组元素。 方法中的局部变量永远不会在线程间共享且不受内存模型影响。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本定义中涉及的部分关键词，在JLS 和JVMS 中的具体落地包括 ：&lt;/p&gt;

&lt;h4 id=&quot;shared-variables---conflicting--jls-1741--shavar&quot;&gt;∙  &lt;strong&gt;共享变量 （Shared Variables ）&lt;/strong&gt; 及 &lt;strong&gt;冲突（Conflicting ）&lt;/strong&gt; 【JLS §17.4.1 】 &lt;sup id=&quot;fnref:ShaVar&quot;&gt;&lt;a href=&quot;#fn:ShaVar&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/h4&gt;
&lt;p&gt;在JSR 133 明确三类共享变量。JLS中，进一步明确 &lt;strong&gt;冲突&lt;/strong&gt; 概念 。&lt;br /&gt;
  所谓 &lt;strong&gt;冲突&lt;/strong&gt; ，就是同时对同一个恭喜变量，同时有两个（或以上）的 “读 ” ， “写 ”访问， 且其中至少存在一个 “ 写 ”访问。 换言之，如果所有的访问都是“读 ”，那么就不存在冲突了。&lt;/p&gt;

&lt;h4 id=&quot;static-fields--jls-8311-stafie&quot;&gt;∙  &lt;strong&gt;实例字段&lt;/strong&gt; 和 &lt;strong&gt;静态字段 （static fields ）&lt;/strong&gt; 【JLS §8.3.1.1 】&lt;sup id=&quot;fnref:StaFie&quot;&gt;&lt;a href=&quot;#fn:StaFie&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/h4&gt;
&lt;p&gt;结合这两个文档的说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;实例字段（或称：实例变量，或：非静态 non-static 字段 ）： 如果一个字段没有被声明为&lt;em&gt;static&lt;/em&gt;， 当它的类被实例化为对象时，这些字段会生成独立的字段变量拷贝，这些变量被称为实例变量。它们属于不同的实例对象，保存在不同的内存地址（注：是保存在 &lt;strong&gt;“堆”&lt;/strong&gt;内存内），可以拥有各自不同的值。 实例对象生成的数量决定了实例变量在内存中的数量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;静态字段（或称：类变量 ）：加上了 &lt;em&gt;static&lt;/em&gt; 声明修饰的类字段。每个类的实例共享它们的类变量，也可以去尝试改变它们的值。类变量仅与类相关，与该类生产实例的数量无关（甚至可以是 0 个），唯一的保存在一个固定内存地址（注：&lt;strong&gt;“堆”&lt;/strong&gt;内存中），不需要通过类实例化后再去操作（manipulate）它。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面这张图做了比较好的示意。  &lt;br /&gt;
    &lt;a href=&quot;https://postimg.cc/p5DnqPpQ&quot; width=&quot;100%&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/3NqCrRhq/20160514fields.png&quot; alt=&quot;字段示意图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原图出处：https://cdn.crunchify.com/wp-content/uploads/2013/04/Java-Instance-Field-Crunchify-Tips-768x395.png&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在【JLS §8.3.1.1 】&lt;sup id=&quot;fnref:StaFie:1&quot;&gt;&lt;a href=&quot;#fn:StaFie&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; 中的几个例子，对于理解包括这两类变量在继承状态下处理原理等，也很有帮助。&lt;/p&gt;

&lt;p&gt;也可以参考： &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html&quot;&gt;Oracle，Java Tutorial：Classes and Objects&lt;/a&gt; 中的表述。&lt;/p&gt;

&lt;p&gt;此处不再进一步展开。&lt;/p&gt;

&lt;h4 id=&quot;local-variables--jls-144--locvar&quot;&gt;∙  &lt;strong&gt;本地变量 （Local Variables ）&lt;/strong&gt;等 【JLS §14.4 】 &lt;sup id=&quot;fnref:LocVar&quot;&gt;&lt;a href=&quot;#fn:LocVar&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/h4&gt;
&lt;p&gt;在JLS 在明确共享变量的同时，也明确了 &lt;strong&gt;本地变量、方法的形式参数以及例外（ exception ）处理参数&lt;/strong&gt; 这三类，不会在线程间共享，也不会受内存模型影响。&lt;/p&gt;

&lt;p&gt;本地变量是指定义在程序块( Block ）中的变量，比如两个“ { }”括起来的部分 。程序块的严格定义略繁琐，不太严格的说，就是一段形成闭合结构的程序片段。 对 Java 语言而言，这里有一个嵌套的概念。比如：if 外面套 for 循环，for 外面再套 switch。我们可以说，每一个都是 Block 。它们组合的每一层，也可以称为 Block 。&lt;/p&gt;

&lt;p&gt;回到主题，对于本地变量等而言，每个线程都在执行时有一套自己的变量拷贝，不存在共享问题。【JVMS §2.6.1】 &lt;sup id=&quot;fnref:JvmsLoc&quot;&gt;&lt;a href=&quot;#fn:JvmsLoc&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; 。  进一步从JVM机制上说，是因为每个线程在调用方法时，会其形成一个不共享的运行帧（Frames，或译作栈帧），而局部变量【注：这里指的变量，不是具体的变量的对象，对象仍然在“堆”内存中 】也被包含在其中。&lt;/p&gt;

&lt;h4 id=&quot;array-variables-----arrays-jls-102-jlsarr---jvms-39--jvmsarr&quot;&gt;∙  数组变量 （ Array Variables ） 和  数组 Arrays 【JLS §10.2 】&lt;sup id=&quot;fnref:JlsArr&quot;&gt;&lt;a href=&quot;#fn:JlsArr&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;  和 【JVMS §3.9 】 &lt;sup id=&quot;fnref:JvmsArr&quot;&gt;&lt;a href=&quot;#fn:JvmsArr&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;&lt;/h4&gt;
&lt;p&gt;数组变量大家都很熟悉。 数组的本质是一组指向对象的地址引用。它有一旦创建，就长度固定的特点。所以，在多线程共享状态下，可能产生以下两种的不安全状态：&lt;/p&gt;

&lt;p&gt;∙ 初始化的冲突。常见的indexOutOfBoundsException。  &lt;br /&gt;
  ∙ 对特定数组指向的对象的值写入和可见问题（共享变量的共同问题）。&lt;/p&gt;

&lt;h4 id=&quot;heap---run-time-areas--jvms-253--jvmsheap-jvms-25jvmsrta&quot;&gt;∙  &lt;strong&gt;堆（Heap ）&lt;/strong&gt; 和 &lt;strong&gt;运行时数据区（Run-Time Areas ）&lt;/strong&gt; 【JVMS §2.5.3 】 &lt;sup id=&quot;fnref:JvmsHeap&quot;&gt;&lt;a href=&quot;#fn:JvmsHeap&quot; class=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt; ，【JVMS §2.5】&lt;sup id=&quot;fnref:JvmsRTA&quot;&gt;&lt;a href=&quot;#fn:JvmsRTA&quot; class=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;&lt;/h4&gt;
&lt;p&gt;关于 &lt;strong&gt;堆&lt;/strong&gt; 和 &lt;strong&gt;栈&lt;/strong&gt; 技术文章很多。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要快速直观认识这两个概念，可阅读 &lt;a href=&quot;https://www.guru99.com/java-stack-heap.html&quot;&gt;Java Stack and Heap: Java Memory Allocation Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里强调以下几点：    &lt;br /&gt;
  ∙ &lt;strong&gt;堆&lt;/strong&gt;中保存所有对象【包括局部变量指向的对象】和数组。   &lt;br /&gt;
  ∙ 类和方法体代码都 &lt;strong&gt;不在&lt;/strong&gt; 堆内，而是在 &lt;strong&gt;方法区（ method area ）&lt;/strong&gt;中 。&lt;br /&gt;
  ∙ &lt;strong&gt;方法区（ method area ）&lt;/strong&gt; 虽然逻辑上也是堆的一部分。但通常不进行垃圾回收，所以一般不作为 我们通常讨论的 &lt;strong&gt;堆&lt;/strong&gt;的范围指向。    &lt;br /&gt;
  ∙ &lt;strong&gt;堆&lt;/strong&gt;里的每个对象都和 &lt;strong&gt;方法区（ method area ）&lt;/strong&gt; 的对应的类相关联 。&lt;/p&gt;

&lt;p&gt;下图较清晰的表现多线程态下的JVM 内存运行时数据区（ Run-Time Data Areas ）逻辑划分：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://postimg.cc/Sj88yfDX&quot; width=&quot;100%&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/CMr4sv84/20160514runtime-Rev.png&quot; alt=&quot;Run-Time Data Areas&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原图复刻自：http://slideplayer.com/slide/12666692/   （原图字体过小）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;inter-thread-actions-&quot;&gt;2. 线程间动作 (Inter-thread Actions ）&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;JSR 133 原文：线程间的动作是由某一线程执行，能被另一线程探测或直接影响的动作（action）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们并不需要真正关心线程内动作（ Intra-thread Actions ）———因为理所当然的是遵循Java语言的语义。&lt;/p&gt;

&lt;p&gt;相对于JSR 133中的表述（此处不再赘述），【JLS §17.4.2 Actions】 &lt;sup id=&quot;fnref:JlsAct&quot;&gt;&lt;a href=&quot;#fn:JlsAct&quot; class=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt;的表述述更加直接一些。归纳来说，有如下若干类线程间动作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Read (normal, or non-volatile)。 读取一个变量。&lt;/li&gt;
  &lt;li&gt;Write (normal, or non-volatile)。写入一个变量。&lt;/li&gt;
  &lt;li&gt;同步（Sychronization ）动作，包括：&lt;br /&gt;
  ∙ Volatile 读。  Volatile方式读取一个变量（注：关于 Volatile 会在另外系列表述）。&lt;br /&gt;
  ∙ Volatile 写。  Volatile方式写入一个变量。&lt;br /&gt;
  ∙ 锁（Lock ）。 锁定一个监视器（或译作：管程）[^ Monitor] 
  ∙ 解锁（Unlock ）。 解锁一个监视器（或译作：管程）
  ∙ 生成线程的第一动作和最后一个动作。 
  ∙ 启动一个线程或者检测线程是否已经中止。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;外部动作（External Actions ） 。 &lt;br /&gt;
  外部动作是可以从外部观察到的（程序）执行动作，结果取决于（程序）执行的外部环境。&lt;br /&gt;
  &amp;gt; JSR 133 ：与外部世界交互的动作。 &lt;br /&gt;
  似乎都有点语焉不详，那么到底是指哪些动作呢？  &lt;br /&gt;
  确切的说，是指：&lt;strong&gt;JIT 编译器无法评估执行效果和影响的，与执行环境相关的动作&lt;/strong&gt;&lt;br /&gt;
  具体来说，包括：&lt;strong&gt;JNI 指令、与外部的socket 通信、对文件系统的操作、与控制台的交互（非排他方式）&lt;/strong&gt;等。 &lt;br /&gt;
  这些动作的共同特点是涉及动作在Java 虚拟机进程的完全控制边界之外（从而无法预先评估结果影响），所以，也 &lt;strong&gt;不会被重排序&lt;/strong&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;JSR 133 ：针对外部动作的参数（例如：准备写入 socket通信的字节流），不属于外部动作的一部分。属于线程的内部动作语义的结果范畴。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;线程分离动作（Thread divergence actions ）。 
 &amp;gt; JSR 133 ：让线程进入无限循环的动作，且这个动作不涉及内存（操作）、同步或外部动作。 
 典型的线程分离动作代码片段：&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;       &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（）&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 线程分离动作 &lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;abc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;     
           &lt;span class=&quot;c1&quot;&gt;//to-do lists#1&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; 
           &lt;span class=&quot;c1&quot;&gt;//to-do lists#2&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
       &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（）&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;abc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
           &lt;span class=&quot;c1&quot;&gt;//TODO somethings &lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;c1&quot;&gt;//TODO some other things &lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
       &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

     &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;按照上述例子，由于thread1 加了线程分离动作 &lt;code class=&quot;highlighter-rouge&quot;&gt;while (true);&lt;/code&gt; , 循环中的&lt;code class=&quot;highlighter-rouge&quot;&gt;abc=123&lt;/code&gt;和 其他 &lt;code class=&quot;highlighter-rouge&quot;&gt;//to-do lists#1&lt;/code&gt; 代码行中的语句不会被 &lt;strong&gt;重排序&lt;/strong&gt;【重排序概念可参见本系列（2）】，即便代码块中, 线程主动插入 &lt;code class=&quot;highlighter-rouge&quot;&gt;sleep（）&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;上述thread1的代码中，如果没有&lt;code class=&quot;highlighter-rouge&quot;&gt;sleep()&lt;/code&gt; 动作，则很可能出现 JLS §17.4.4所说的导致其他线程停止或挂起（没办法继续执行）的情况。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thread divergence actions are introduced to model how a thread may cause all other threads to stall and fail to make progress.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;线程分离动作的应用场景可能有两个：&lt;br /&gt;
    ∙  确保某些线程沿着预期的分支走（比如在测试的时候）。 &lt;br /&gt;
    ∙  在某种状态下，让一部分线程完全进入阻塞状态 。&lt;/p&gt;

&lt;p&gt;关于线程分离还需要明确的一点： 例子里的 abc 的字段，无论是否采用 atomic 类型，都不能确保线程间相互的“可见”完全如预期。换言之，thread2中的两个分支的执行顺序，并不能做确定的假设。除非在程序中加入更强约束的，&lt;/p&gt;

&lt;h3 id=&quot;program-order-intra-thread-semantics&quot;&gt;3. 程序顺序 (Program Order ）和线程内语义（Intra-thread semantics）&lt;/h3&gt;
&lt;p&gt;这两个定义，都是为了界定一个线程，在隔离或孤立运行状态下，正确的执行顺序和执行语义。
此处不再重复 JSR 133 中的表述。&lt;/p&gt;

&lt;p&gt;这里需要了解的一个重要的概念是在 【JLS §17.4.3 】&lt;sup id=&quot;fnref:JlsSeq&quot;&gt;&lt;a href=&quot;#fn:JlsSeq&quot; class=&quot;footnote&quot;&gt;11&lt;/a&gt;&lt;/sup&gt; 中提到的 顺序一致性 （ Sequential consistency ） 问题 。顺序一致性是保证可见性和有序性的强保证。换言之，运作环境可以把多线程的行为，进行全局排序执行，且每个动作都是原子的，就像单线程那样，那么，就不会存在数据竞争 （ Data Race）了。&lt;/p&gt;

&lt;p&gt;实现严格顺序一致性处理的代价是很大的，尤其对于多核系统而言。 所以，我们显然需要更 &lt;strong&gt;自由&lt;/strong&gt; 顺序的内存模型，不同线程间不需要假定相对顺序，而是接下来要说的同步动作和同步顺序来进行竞争与协作。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;未完待续&lt;/h2&gt;

&lt;p&gt;接下来，我们就要借着原文 FAQ 的中相关问题，继续聊一聊同步动作和同步顺序，以及 happen-before 等问题了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考链接汇总:&lt;br /&gt;
 -&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html&quot;&gt;Oracle， Java Tutorial：Classes and Objects&lt;/a&gt; &lt;br /&gt;
 -&lt;a href=&quot;https://crunchify.com/java-tips-never-make-an-instance-fields-of-class-public/&quot;&gt;Java Tips: Never Make an Instance Fields of Class Public&lt;/a&gt;&lt;br /&gt;
 -&lt;a href=&quot;http://slideplayer.com/slide/12666692/&quot;&gt;CS432:Compiler Construction lecture 15&lt;/a&gt;  &lt;br /&gt;
 -&lt;a href=&quot;https://www.guru99.com/java-stack-heap.html&quot;&gt;Java Stack and Heap: Java Memory Allocation Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;参考索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;*&lt;end&gt;*&lt;/end&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:JSR133&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf&quot;&gt;JSR-133: JavaTM Memory Model and Thread Specification &lt;/a&gt; &lt;a href=&quot;#fnref:JSR133&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ShaVar&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.1&quot;&gt; JLS §17.4.1 Shared Variables &lt;/a&gt; &lt;a href=&quot;#fnref:ShaVar&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:StaFie&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se10/html/jls-8.html#jls-8.3.1.1&quot;&gt;JLS §8.3.1.1 static fields &lt;/a&gt; &lt;a href=&quot;#fnref:StaFie&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:StaFie:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:LocVar&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se10/html/jls-14.html#jls-14.4&quot;&gt; JLS §14.4 Local variables &lt;/a&gt; &lt;a href=&quot;#fnref:LocVar&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:JvmsLoc&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-2.html#jvms-2.5.3&quot;&gt;JVMS §2.6.1 Local variables&lt;/a&gt; &lt;a href=&quot;#fnref:JvmsLoc&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:JlsArr&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se10/html/jls-10.html&quot;&gt;JLS §10.2 Array Variables &lt;/a&gt; &lt;a href=&quot;#fnref:JlsArr&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:JvmsArr&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-3.html#jvms-3.9&quot;&gt;JVMS §3.9 Arrays &lt;/a&gt; &lt;a href=&quot;#fnref:JvmsArr&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:JvmsHeap&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-2.html#jvms-2.5.3&quot;&gt;JVMS §2.5.3 Heap &lt;/a&gt; &lt;a href=&quot;#fnref:JvmsHeap&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:JvmsRTA&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-2.html#jvms-2.5&quot;&gt;JVMS §2.5  &lt;/a&gt; &lt;a href=&quot;#fnref:JvmsRTA&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:JlsAct&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.2&quot;&gt; JLS §17.4.2 Actions &lt;/a&gt; &lt;a href=&quot;#fnref:JlsAct&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:JlsSeq&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html#jls-17.4.3&quot;&gt; Sequential consistency &lt;/a&gt; &lt;a href=&quot;#fnref:JlsSeq&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Ryan Wang (Haide1977)</name><email>haide1977 AT gmail.com</email></author><category term="架构" /><category term="并发与并行" /><category term="开发语言" /><summary type="html">前言

如果真正对Java 语言和 JVM 的很多底层细节和原理有兴趣，那么，阅读官方的 Java 语言规范 （The Java Language Specification  简称 JLS ）和 Java 虚拟机规范 （The Java Virtual Machine Specification  简称 JVMS ） ，无疑是最有帮助的，也最原汁原味。但是，对于很多研发人员来说，阅读这样的文档，无疑是一种挑战 。</summary></entry><entry><title type="html">JSR 133 FAQ的翻译和扩展（2）—— 内存模型的困扰</title><link href="http://0.0.0.0:4000/2016/01/22/JSR_133_FAQ_Trans_and_Ext_P2_Volatile_Reordering.html" rel="alternate" type="text/html" title="JSR 133 FAQ的翻译和扩展（2）—— 内存模型的困扰" /><published>2016-01-22T00:00:00+08:00</published><updated>2016-01-22T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2016/01/22/JSR_133_FAQ_Trans_and_Ext_P2_Volatile_Reordering</id><content type="html" xml:base="http://0.0.0.0:4000/2016/01/22/JSR_133_FAQ_Trans_and_Ext_P2_Volatile_Reordering.html">&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;多线程并发态下的内存模型经常带给开发者的困扰，概括来说就是反直觉（ counterintuitive ）。
看上去代码逻辑没有问题啊，但是结果却出乎了我们的预料。这类问题实际更像是“ 一个硬币的两面 ”。&lt;/p&gt;

&lt;p&gt;本部分，会结合FAQ原文中的“重排序（Reordering ）” 和“旧的内存模型的问题” 等相关问题来展开相关讨论。&lt;br /&gt;
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;硬币的两面&lt;/h2&gt;
&lt;p&gt;一面，在多数情况下，是开发者对该开发语言底层原理，包括与之相关体系架构的代码编译和运行时（Run time ）逻辑并不真正的了解，而仅仅是站在高级语言的角度去揣测低层运行行为。这一点，是高级语言的程序开发和书写汇编语言程序的一个重要的差别。&lt;/p&gt;

&lt;p&gt;另外，有些高些语言，为了提升业务逻辑的开发效率、平缓学习曲线，也会无意间向开发者传递这样的错觉。&lt;/p&gt;

&lt;p&gt;在单线程态下的程序代码，开发者的上述不足，基本可以通过测试用例的设计来弥补，因为其中潜在问题的复现是相对稳定的。而在多线程态的程序代码中，由于存在更多的不确定性，这类BUG 往往会躲过不完善的测试【注1】，被发布到生产环境中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注1: 本系列会在覆盖其他有关知识点后，对这类场景下的“ 测试 ”问题 进行专题梳理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另一面，任何一个语言的编译器、运行时（Run time ）的优化，同样需要一个较漫长的过程。真正的稳定成熟，从Java ，
或者Go 来看，差不多需要10 年左右周期。2004 年，对JVM 而言，差不多到了这样的演进节点。对于Go 这样的新生语言来说，内存模型或许不再需要完全摸石头，但是新的场景同样意味着新的挑战&lt;sup id=&quot;fnref:ToGo2&quot;&gt;&lt;a href=&quot;#fn:ToGo2&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;【注2】。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注2：本段在2018年初，重新进行了修订。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-2&quot;&gt;▸旧的内存模型哪些问题？【译】&lt;/h2&gt;

&lt;p&gt;[原文]&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#oldmm&quot;&gt;What was wrong with the old memory model?&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;翻译注：&lt;br /&gt;
本段提到的final，volatile等语言结构，会在系列的其他部分中单独讨论，此处暂不需展开。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;旧的内存模型存在一些严重的问题。由于理解起来困难，也存在大量的使用背离。例如，在很多场景下，旧的内存模型，不允许在 JVM 中发生多种的重排序。 这种旧内存模型的潜规则的困扰在 JSR-133 中被正式的公式化表达了出来。 &lt;br /&gt;
 &lt;br /&gt;
之前有一个被广泛确信的想法是，如果使用了 final 字段，那么线程间的同步时，就不需要去额外保证去确保另一个线程对这个字段值的可见。然而，这个貌似合理的假设且明智的行为模式，在旧的内存模型里，当我们真希望事情如此进展的时候，显然情况不是真的（如此）。在旧的内存模型里，对待 final 字段与其它任何字段，并无二致——这意味着，同步处理是保证所有线程可以看到被构造器写入后的 final 字段值的唯一途径。由于（在旧的内存模型里）一个线程既可能看到这个字段的默认值，也可以在之后看到它被构造后的值。也就是说，例如，一些不可变对象，如 String ，可以看上去它们在改变自己的值 —— 这着实是令人困扰的预期。   &lt;br /&gt;
 &lt;br /&gt;
旧的内存模型允许可变的（ volatile ）（字段）“ 写 ”与不可变的（ nonvolatile ）字段的“ 读 ”，“ 写 ” 进行重排序，这与大部分开发人员对于可变的（ volatile ）语义的直观理解不一致，并会由此产生困扰。  &lt;br /&gt;
 &lt;br /&gt;
最后，正如我们所见，编程人员对于他们的程序在不正确地同步时会发生什么的直觉，通常是错误的。 JSR-133 的其中一个目标，也是为了让这一事实引起注意。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;▸重排序的含义是什么? 【译】&lt;/h2&gt;

&lt;p&gt;[原文]&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#reordering&quot;&gt;What is meant by reordering? &lt;/a&gt;  &lt;br /&gt;
 &lt;br /&gt;
在很多场景里，访问程序变量（对象实例的字段，类静态字段及数组元素）的执行顺序可能不同于程序中确定的顺序。编译器可以根据优化的需要，自由地改变指令的执行顺序【注3】 。在某些特定的环境下，处理器会打乱执行指令的顺序。数据也可能不按照程序中设定的顺序在寄存器、处理器缓存和主存间移动。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注3：本文后半部分有对指令执行相关的补充。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;例如，如果一个线程先写字段 a ，然后写 b ，且 b 的值不依赖 a 的值的话，编译器可以自主地重排序这几个操作，而且缓存也可以自主地，在 a 之前，把 b 刷新到内存。存在许多潜在的重排序根源，比如，编译器、 JIT （翻译注：这里应该是指实时编译器，后文会有补充）和缓存等。&lt;/p&gt;

&lt;p&gt;编译器，运行时（runtime ）和硬件共同造成了一种 “ 看上去顺序化( as-if-serial) ” 的语义假象，即，在单线程的程序里，应该不能够观察到重排序的效果。然而，在不正确地同步的多线程程序中，重排序的效果就会显现出来。此时，一个线程能够感受到其它线程的影响，可能会发现对其它线程可见的变量访问（variable accesses ）的顺序，与程序内设定的或者执行的顺序是不一样的。   &lt;br /&gt;
 &lt;br /&gt;
大多数时候，一个线程不关注其它线程在做什么。但是，如果需要在意的话，就需要涉及到同步了（ that’s what syschronization is for ）。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;与重排序有关的概念和语义&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;§ 指令周期与重排序&lt;/h3&gt;
&lt;p&gt;一般而言，CPU 的指令周期主要包括四个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;获取指令 Fetch the instruction&lt;/li&gt;
  &lt;li&gt;解析指令 Decode the instruction 。解码指令的过程也会把指令所需数据等从主存中载入（ load ）&lt;/li&gt;
  &lt;li&gt;执行指令 Execute the instruction&lt;/li&gt;
  &lt;li&gt;写回（ Write- Back ）结果。 把指令产生的结果数据写回（ Store）主存等存储中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;或者像类似下面的伪代码表述（这里没有包含例外处理过程）&lt;sup id=&quot;fnref:IssJvms&quot;&gt;&lt;a href=&quot;#fn:IssJvms&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;  
  do {
      // pc-- program counter 指令计数器 
      // opcode--  指令码 ，JVM的指令码长度为1个字节。
      atomically calculate pc  and fetch opcode at pc;  

      //operands   操作数，一条指令码可能需要 {0...n}个操作数。 
      if (operands) fetch operands;
      execute the action for the opcode;
   } while (there is more to do);  
 &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;不同的 CPU 有不同的指令集，也有不同的指令周期，具体载入和写回的策略也有不同，实际情况远远比这四个步骤更多，也更复杂。但总体不影响讨论重排序主题。&lt;/p&gt;

&lt;p&gt;由于2，4 两个步骤，涉及到数据与存储间的操作，相对与 CPU 有多个数量级的速度差，很容易成为阻塞指令的瓶颈。为了使 CPU 在每个时钟周期都不空闲，所以有了“指令管道（ Instruction Pipeline ）” 【详细内容可参见 wikipedia】&lt;sup id=&quot;fnref:PipeWiki&quot;&gt;&lt;a href=&quot;#fn:PipeWiki&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;和 “分发队列 （ Dispatch Queue ）”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;指令管道 （ Instruction Pipeline ）&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Pipeline%2C_4_stage_with_bubble.svg/350px-Pipeline%2C_4_stage_with_bubble.svg.png&quot; alt=&quot;指令管道示意图（来自wiki）&quot; title=&quot;指令管道示意图&quot; /&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;原图出处：&lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction_pipelining&quot;&gt;https://en.wikipedia.org/wiki/Instruction_pipelining&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;绿、紫、蓝、红分别代表了指令管道中并行的四条指令。&lt;/p&gt;

    &lt;p&gt;蓝色椭圆代表了该时钟周期（ Clock Cycle）出现的指令执行空闲。按照上面示意图来说，紫色这条指令，从“解析指令”开始，由于某种原因（也许是数据尚未准备好），堵塞了一个时钟周期。从而导致了所有四条指令的完成往后拖延了一个时钟周期。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分发队列 （ Dispatch Queue ）&lt;br /&gt;
分发队列从解析指令／写回指令的工作中，把Load 和 Store这两个动作相对松耦合的独立出来，从而进一步降低指令执行堵塞的可能性。这样的设计是很合理、自然的思路。显然对提高 CPU 的整体性能有利。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;JVM spec v2中定义的 Load 和 Store 主要四类指令，可参考：&lt;br /&gt;
&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.11.2&quot;&gt;https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.11.2&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有了上述提高性能的设计的描述补充，再来理解前文提到的重排序场景就比较容易了，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CPU 的指令调度算法，必然不会容忍大片时钟周期的空闲，会将当前具备运行条件的指令提高优先级，反之亦然。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多个 CPU + 多个指令管道的模式下，如果没有特定的指令语义约束，期望严格有序几乎是不可能的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分发队列，为了保证其自身的分发性能，必然也会对不同读写速率的数据分发做必要的重排。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jit&quot;&gt;§ JIT与重排序&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://postimg.cc/BP48VxTt&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/6qGdTcTV/20160122jit.png&quot; alt=&quot;JIT原理图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原图出处：http://belajarjava-19.blogspot.jp/2011/05/jdk-dan-jre.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于程序代码中的一个特定的方法而言，JIT（Just-In-Time ）编译 &lt;strong&gt;当且仅当&lt;/strong&gt; 该方法第一次被调用，需要把它从字节码编译为本地可执行代码的时候会发生。&lt;/p&gt;

&lt;p&gt;JIT 这样的动态编译（ Dynamic Compliation ）&lt;sup id=&quot;fnref:JitWiki&quot;&gt;&lt;a href=&quot;#fn:JitWiki&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; 的区别与静态编译（ Static Compliation ）的一个明显好处是：可以根据实时运行态的状况，对代码进行简单的优化。这些优化包括：&lt;strong&gt;优化循环嵌套、把堆栈操作变成寄存器操作、通过分配寄存器来减少内存访问、减少不必要的中间表达式等&lt;/strong&gt; 。这个过程，有点类似现在的 DBMS（ 数据库管理系统 ） 对 SQL 的优化，可以一定程度建立在对在表和数据的特征统计基础上，而不是单纯的依据规则。&lt;/p&gt;

&lt;p&gt;所以，对于这个过程中，重排序的产生，就很顺理成章了。&lt;/p&gt;

&lt;p&gt;不同的 VM 对 JIT 优化能力和结果的差别可以是巨大。  对于应用开发者而言，我们最后还需要清楚 &lt;strong&gt;优化过程本身也需要消耗 CPU 和内存等资源&lt;/strong&gt;。 所以，不妨可以多看看诸如 &lt;em&gt;《java高性能代码编写》&lt;/em&gt; 之类的总结文章。这是题外话 。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;更多关于JIT编译和优化的内容，可参考：&lt;br /&gt;
 - &lt;a href=&quot;https://www.oreilly.com/library/view/java-performance-the/9781449363512/ch04.html&quot;&gt;https://www.oreilly.com/library/view/java-performance-the/9781449363512/ch04.html &lt;/a&gt;  &lt;br /&gt;
 - &lt;a href=&quot;https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/&quot;&gt;https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/&lt;/a&gt;  &lt;br /&gt;
 - &lt;a href=&quot;https://dzone.com/articles/performance-improvements-via-jit-optimization&quot;&gt;https://dzone.com/articles/performance-improvements-via-jit-optimization&lt;/a&gt;  &lt;br /&gt;
 (新修订补充)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;as-if-serial--happen-before-&quot;&gt;§ as-if-serial 和 happen-before 语义&lt;/h3&gt;
&lt;p&gt;前面都是讲的重排序场景出现的可能性。但是，需要强调的是，对单线程运行的一段程序而言，有一个限制指令重排的强约束，即，执行结果需要是稳定的、符合预期的———否则就变成了违背代码语义———没有了正确性，性能优化本身就失去了意义。&lt;/p&gt;

&lt;p&gt;as-if-serial 和 happen-before 本质含义是相同的。 即要遵循严格的事件偏序关系&lt;sup id=&quot;fnref:HBWiki&quot;&gt;&lt;a href=&quot;#fn:HBWiki&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;。 
简而言之，就要满足三个基本特性：&lt;strong&gt;传递性、反自反性，反对称性&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;另外，happen-before 的语义，会在本系列后续 涉及“同步”时，再进行讨论。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;一沙一世界&lt;/h2&gt;
&lt;p&gt;目前为止，本篇都在偏底层的角度讨论一些原理。对很多应用开发者而言，这些偏理论的细节与实际工作似乎很遥远。 其实，从单CPU 的并发、多处理器内核的并行，再到基于消息的分布式计算架构以及现在火热的微服务架构，思考的基本框架基本是一脉相承的。差别更多是在所聚焦问题粒度：是更微观的指令（ Instruction ）层面，还是更宏观层面的任务（ Tasks ）、服务 （ Services ）。&lt;/p&gt;

&lt;p&gt;下面的这个列表，几乎是现在分布式架构和开发工作中每天要思考的问题（实际上还远不止）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;分解。分解的策略和分解的粒度 （虽然我们不需要到指令级别）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解耦。把非核心流程业务剥离到不同的事务队列管道中去。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通信。通信策略，通信协议。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有序和幂等。 消息的传递如何兼顾性能和准确性？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调度策略。 优先级／资源调度／迁入迁出。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;流量控制和忙碌等待。本质上没有跑出阻塞／活锁／死锁等的范畴。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据同步。永恒的焦点。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;参考索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;*&lt;end&gt;*&lt;/end&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:ToGo2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.golang.org/toward-go2&quot;&gt;the Go Blog ：Toward Go 2 &lt;/a&gt; &lt;a href=&quot;#fnref:ToGo2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:IssJvms&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.11&quot;&gt;JVM spec :Instruction Set Summary  &lt;/a&gt; &lt;a href=&quot;#fnref:IssJvms&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:PipeWiki&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction_pipelining&quot;&gt; Instruction pipelining &lt;/a&gt; &lt;a href=&quot;#fnref:PipeWiki&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:JitWiki&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;Just-in-time_compilation&quot;&gt;Just-in-time_compilation &lt;/a&gt; &lt;a href=&quot;#fnref:JitWiki&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:HBWiki&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Happened-before&quot;&gt;Happened-before &lt;/a&gt; &lt;a href=&quot;#fnref:HBWiki&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Ryan Wang (Haide1977)</name><email>haide1977 AT gmail.com</email></author><category term="架构" /><category term="并发与并行" /><category term="开发语言" /><summary type="html">前言
多线程并发态下的内存模型经常带给开发者的困扰，概括来说就是反直觉（ counterintuitive ）。
看上去代码逻辑没有问题啊，但是结果却出乎了我们的预料。这类问题实际更像是“ 一个硬币的两面 ”。

本部分，会结合FAQ原文中的“重排序（Reordering ）” 和“旧的内存模型的问题” 等相关问题来展开相关讨论。</summary></entry><entry><title type="html">JSR 133 FAQ 的翻译和扩展（1）——关于内存模型</title><link href="http://0.0.0.0:4000/2016/01/08/JSR_133_FAQ_Trans_and_Ext_P1_Memory_Model.html" rel="alternate" type="text/html" title="JSR 133 FAQ 的翻译和扩展（1）——关于内存模型" /><published>2016-01-08T00:00:00+08:00</published><updated>2016-01-08T00:00:00+08:00</updated><id>http://0.0.0.0:4000/2016/01/08/JSR_133_FAQ_Trans_and_Ext_P1_Memory_Model</id><content type="html" xml:base="http://0.0.0.0:4000/2016/01/08/JSR_133_FAQ_Trans_and_Ext_P1_Memory_Model.html">&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;网上有很多JSR 133 FAQ 的中文翻译版本，一大半是大家为便于自己的学习理解，做的读书笔记似的翻译。这一点上，这个版本也不例外。&lt;/p&gt;

&lt;p&gt;不过, 本系列版本，尝试在不打破原文表达结构，更准确翻译表述的基础上，尝试对于一些关键概念，特别是随着时间推移已经有所变化的知识点，做一些拓展梳理。&lt;br /&gt;
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;关于内存模型&lt;/h2&gt;
&lt;p&gt;一句话表述：内存模型（Memory Model）描述了在进行计算时，&lt;strong&gt;线程间&lt;/strong&gt;如何通过&lt;strong&gt;内存&lt;/strong&gt;和&lt;strong&gt;共享数据的使用&lt;/strong&gt;来进行&lt;strong&gt;交互&lt;/strong&gt;。（Wikipedia）&lt;/p&gt;

&lt;p&gt;维基百科上关于内存模型的说明有一部分就引用自JSR 133，这里暂不再展开。&lt;sup id=&quot;fnref:WikiMM&quot;&gt;&lt;a href=&quot;#fn:WikiMM&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&quot;jsr-133&quot;&gt;关于JSR 133&lt;/h2&gt;
&lt;p&gt;既然有“JSR 133 常见问题（FAQ ）”，顺理成章的思路，第一个问题似乎应该是：JSR 133是什么？&lt;/p&gt;

&lt;p&gt;但是这个FAQ 英文原文的组织方式，却不是这样（原文是作为JSR 133 系列文档的一部分，这样的组织也是没有问题的）。这里，为避免有人陷入缺少上下文的迷惑，这里先简述下JSR 133 ————更具体的内容，将在本系列（2）中说明。&lt;/p&gt;

&lt;p&gt;一句话描述JSR 133:  表述线程（threads）,锁（locks），volatile变量和数据竞争（data races）语义的Java语言建议规范，它包括了称为Java内存模型的内容。&lt;/p&gt;

&lt;p&gt;这一句话里的关键词看上去信息量够大，够技术，够诱人吧？&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;▸为什么我要关注内存模型? 【译】&lt;/h2&gt;

&lt;p&gt;[原文]&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#conclusion&quot;&gt;why should I care?&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;翻译注：&lt;br /&gt;
这本来是FAQ 原文的最后一个问题，但我觉得放在这里似乎更合适。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为什么你应该关注？因为并发的 bug 是非常难调试的。这类 bug ，在测试的时候，通常不会被发现，直到程序跑在重负荷的状态时才会暴露；要重现和捕获也很困难。 
所以，最好把额外的功夫花在前面———确保你程序会被正确地同步；虽然，这也不太容易，但是比起花大量的时间去调试一个糟糕的同步程序，可能还是会简单很多。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;▸那么,内存模型到底是什么? 【译】&lt;/h2&gt;

&lt;p&gt;[原文]&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#whatismm&quot;&gt;What is a memory model, anyway?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在多处理器系统中，处理器通常有一个或多个内存缓存层（layers of memory cache ）来改善性能————比如，加速数据的访问（通过让数据离处理器更近），或者降低共享内存总线上的流量（因为许多内存操作可以通过本地缓存来满足）。 虽然内存缓存能极大改善性能，但也会成为新的挑战的根源。例如，当两个处理器在同一时间来查看同一个内存地址时，在什么情况下，它们会看到相同的值？ &lt;br /&gt;
 &lt;br /&gt;
在处理器层面，内存模型定义了充要条件来明确： &lt;br /&gt;
其它处理器对内存的写入（如何）对当前处理器可见； &lt;br /&gt;
当前处理器对内存的写入（如何）对其它处理器可见。&lt;/p&gt;

&lt;p&gt;一些处理器呈现的是强内存模型（strong memory model ），在这种模型下，所有处理器在任意相同时刻，看到该内存地址的值，是保证相同的。其它处理器提出了的一种弱内存模型（ weak memory model ），需要借助特定的指令，所谓内存壁垒（ memory barries，也有翻译“内存屏障” ），通过清空（ flush ）或者失效（invalidate ）本地缓存，来看到其他处理器的 “写” ，或让本处理器的 “写” 对其他处理器可见。 这些内存壁垒通常在执行锁（lock ）和解锁（unlock ）操作中体现（performed ）；而且，它们对于高级语言的编程者（high level programmers ）是不可见的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;翻译注：&lt;br /&gt;
关于强、弱内存模型模型的问题，本文后半部分有补充叙述。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为降低了对内存壁垒（内存屏障）处理的要求，所以，有时候，在强内存模型下写程序会简单一些。然而，即使在最强的内存模型（ strongest memory model ）里，内存壁垒也经常是必要的；更常见的是，它们的处置方式还会背离（我们）的直觉意图（counterintuitive ）。最近的处理器设计趋势，多倾向于弱一些的内存模型（weaker memory model ）。因为这样的（约束）放松，可以让缓存一致性（问题）（cache consistency ）在跨多处理器和更大内存的（场景下），有更大的可伸缩性（greater scalability ）。 &lt;br /&gt;
 &lt;br /&gt;
什么时候 “ 写 ” 操作（的结果）变成对于其他线程是可见的，这个问题取决于（ compounded ）编译器的代码重排序（ reordering of code ）结果；例如：编译器可能认定 “ 写 ” 放在程序的更后面（后移）会更有效率，只要这段代码的行为没有改变程序的语义，就可以被允许这样做。当编译器推迟执行一个操作时，在此操作被执行完之前，对另一个线程而言是不可见的。这也反映了缓存的作用。&lt;/p&gt;

&lt;p&gt;此外， “ 写 ” 内存也可以在程序中提前（前移）。在这种场景下，其他线程可能比实际程序发生（ actually “occurs” in the program ）更早的看到一个 “ 写 ” 内存（翻译注：可能会读到违背代码原意的值）。所有的这些灵活性都是被设计出来的 —— 在特定的内存模型的边界（ bounds ）内，通过给予编译器、运行环境或者硬件，在执行操作时，优化顺序执行的灵活性，来获得更好的性能。 &lt;br /&gt;
 &lt;br /&gt;
一个简单的例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reordering&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;          
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;        
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;       
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;    
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;         
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;        
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;             
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;         
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;        
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;        
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;        
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;比如说，这段代码在两个线程中并发执行，且对 y 读取到值 2 。因为程序中对 y 的写是在 x 之后，所以，编程人员可能会假设此时能读取 x 的值会是 1 。然而，实际上，这段写操作可能会被重排序（ reordered ）。如果这个情况真的发生了，那么有可能， y 先被写成了 2 ，然后对 x ， y 两个变量的读取接着进行，最后对 x 的写操作才会开始。此时的结果就可能变成了 r1 的值等于 2 ，而 r2 的值却还是 0 。   &lt;br /&gt;
 &lt;br /&gt;
java 内存模型描述了什么样的行为在多线程的代码中是合法的（legal in multithreaded code ），以及线程与内存的可能交互方式。同时，描述了程序代码中的变量与它们在真实计算机系统的内存或寄存器中的存、取的底层（low－level ）细节之间的关系。以便通过这种方式，保证代码在差异巨大的硬件和不同的编译器优化时，都能够正确的实现。   &lt;br /&gt;
 &lt;br /&gt;
java 包含了若干的语言结构，包括 volatile ， final 和 synchronized , 以帮助编程人员向编译器表述一段程序的并发（状态下的）需求。 java 内存模型不仅定义了 volatile 和 synchronized 的行为方式，而且，更重要的是，保证了（任意）一段（包含了）正确同步（ synchronized ）处理的java 程序代码在所有处理器架构下都能正确地运行。&lt;/p&gt;

&lt;h2 id=&quot;c-&quot;&gt;▸其他语言，比如C++ ，有内存模型么？【译】&lt;/h2&gt;

&lt;p&gt;[原文]&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#otherlanguages&quot;&gt;Do other languages, like C++, have a memory model?&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;翻译注：&lt;br /&gt;
原文写于2004年，实际上很多情况近些年已经发生了变化。具体内容请见后文。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大多数的其他编程语言，像 C 和 C++ ，都没有设计针对多线程（ multithreading ）的直接支持。这些语言提供的，对于发生在不同编译器和架构下的重排序（ reordering ）的各种保护，都严重依赖于所用编译器及代码运行所在平台使用的特定线程库（ threading libraries ）的保证（ guatantees ），例如 pthreads 。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;翻译注：&lt;br /&gt;
这里的 pthreads 应该指的是 POSIX thread  库（ www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads .html ），而不是 php 的多线程库 pthread （参见： pthreads.org&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-4&quot;&gt;关于内存模型的补充&lt;/h2&gt;

&lt;p&gt;自2004年2月，这篇著名的FAQ 发布以来，互联网世界已经发生了巨大的变化。例如，那时还没有Github，没有Go  语言，也没有双十一这样制造瞬间高并发的购物节；移动应用还处于wap ，stk 、短信这样的初级阶段；很多人在帮客户做技术方案时，还要向用户宣讲B/S 还是C/S 的优劣比较…. 等等 。&lt;/p&gt;

&lt;p&gt;还有，作为Java语言的发明者及第一个JVM的推出者的Sun公司，应该没有完全预料到自己会在短短5年后被Oracle收购。&lt;/p&gt;

&lt;p&gt;近10年里，主要的编程语言也是在相互借鉴中演进，语言的特性已经不像早期那样泾渭分明了。总体来说，多是为了适应计算和开发场景的需求，特别是越来越多服务端面对高性能、高并发的要求，以及普遍的分布式，大规模并行的架构特点。&lt;/p&gt;

&lt;p&gt;一些经典的语言（如C++ ）的新标准中，补充了这部分缺失的特性。而新的语言，如Go  ，在一开始就加入了这样的特性。 虽然语言不同，但从理论基础角度讲，差别并不大。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;§ 内存模型中的“内存”&lt;/h3&gt;

&lt;p&gt;众所周知，Java语言当初诞生的一个核心理念是 “Write once，run anywhere”   ————当然，最后演变成了“Write once ，Debug everywhere” ————但是，为了支撑这一理念，必须抽象出一个与硬件架构相对无关的JVM规范。对上，作为应用开发者的规范，对下，作为开发不同架构下JVM的依据。所以，很明显，JVM 内存模型中的内存，实际是个抽象概念，对应到具体计算机系统，可能涵盖CPU寄存器、CPU 缓存（诸如，一级缓存，二级缓存等等）以及内存。&lt;/p&gt;

&lt;p&gt;对于绝对多数不会去参与JVM 开发的应用研发人员来说，对这个 “内存” 问题，目前了解到这一点，已经基本够了。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;§ 处理器的内存模型&lt;/h3&gt;

&lt;p&gt;前面译文中，有较多篇幅提到“处理器”的强、弱内存模型。这个话题涉及到计算机体系架构。随着并行运算框架的成熟和pc 服务器的流行，x86 以外的处理器架构，似乎已经渐渐淡出一般开发人员的视野了。实际上，现在的大部分处理器按照“放松的一致性”（Relaxed Consistency ）方式在运转，因为性能永远是处理器的第一追求。当然，问题的另一面是，几乎所有的处理器事实上都是可以支持严格的顺序一致性的————即所有的 “写” 的行为都要被从缓存中刷入主存以后，才能被读取。&lt;/p&gt;

&lt;p&gt;所以，了解还有很多不同内存模型的处理器&lt;sup id=&quot;fnref:MemPaul&quot;&gt;&lt;a href=&quot;#fn:MemPaul&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;，比如大量存在移动计算节点的ARM架构，对于我们开发一些特定应用时，或许会增加一些避免犯错的预见能力。&lt;/p&gt;

&lt;h3 id=&quot;c--1&quot;&gt;§ C++ 的内存模型&lt;/h3&gt;

&lt;p&gt;在C++标准1998(C++89 ) 年版发布了13年以后，新的C++标准2011版（C++11 )，终于增加了多线程特性的支持&lt;sup id=&quot;fnref:Cpp11&quot;&gt;&lt;a href=&quot;#fn:Cpp11&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; 。&lt;/p&gt;

&lt;p&gt;在C++11 中，发布了的并发内存模型最终版本&lt;sup id=&quot;fnref:CppMM&quot;&gt;&lt;a href=&quot;#fn:CppMM&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;,原子类型和操作(Atomic Types and Operations )，线程本地存储（Thread-Local Storage ）等 。而在此之前，就像前述FAQ原文所说，需要严重依赖线程库的支持。 但是，利用POSIX这类库的来实现，往往不够优雅，而且存在性能的问题。这类类库对于把单线程的应用转换为多线程应用时候，也不是特别的有帮助。C++11 大致相同的实现了一些厂商（包括IBM ，Intel 等）实现的对线程本地存储这部分的语言扩展&lt;sup id=&quot;fnref:CppAtom&quot;&gt;&lt;a href=&quot;#fn:CppAtom&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&quot;fnref:CppTLS&quot;&gt;&lt;a href=&quot;#fn:CppTLS&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;为了在C++代码中可以有下面的一句声明，背后的工作实际上是大量的。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;  
  &lt;span class=&quot;cp&quot;&gt;#include &amp;lt;thread&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;大量支持高性能、高并发的C++ 的组件和项目支撑着当今互联网世界的核心骨架。目前最受瞩目的两大应用趋势，人工智能和区块链也毫不例外，其中包括流行的机器学习和神经网络库 tensorflow ，caffe；比特币和以太坊的核心实现等等。&lt;/p&gt;

&lt;p&gt;C++ 并发编程这个主题不再这里进一步展开了。有一本对C++11 标准相对实操的”名”著（目前已出第二版） &lt;em&gt;“C++ Concurrency in Action”&lt;/em&gt; &lt;sup id=&quot;fnref:CppAction&quot;&gt;&lt;a href=&quot;#fn:CppAction&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;，可在对相对抽象的官方文档了解地基础上延伸阅读。&lt;/p&gt;

&lt;h3 id=&quot;go-&quot;&gt;§ Go 的内存模型&lt;/h3&gt;

&lt;p&gt;本段要讨论，不是Go语言的语法。只是作为获得越来越多社区支持，为并发编程而生的语言样本进行研究。&lt;/p&gt;

&lt;p&gt;JSR 133 开创了从语言规范层面思考和定义内存模型的先河。所以在多年以后，仍然被开发人员不断拿出来解读，也成为其他语言在演进或者创造时，必然要思考的问题框架。&lt;/p&gt;

&lt;p&gt;Go从语言层面定义了”goroutine “ ————由Go运行环境管理的轻量级线程,确切的说，更接近于协程&lt;sup id=&quot;fnref:Corou&quot;&gt;&lt;a href=&quot;#fn:Corou&quot; class=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;。一个程序在初始化时，只运行了一个goroutine 。 由这个goroutine，可以创建出其他并发运行的goroutine 。&lt;/p&gt;

&lt;p&gt;先看几行的代码的例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span class=&quot;x&quot;&gt;  
  &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 假设有一个函数 f(x,y,z) ,每增加一行下面的代码，可以启动一个新的并发执行的goroutine &lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; 
  &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 如果我们把函数 f（）变成我们更加熟悉的两个函数名呢？   &lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;produce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;  
  &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;在其他一些语言，如Java ，可能需要用线程来实现的 “生产” 和 “消费” 例子，
这里Go语言中，可以用两个并发执行的goroutine 实现。更重要的是，goroutine 不依赖于CPU内核数量，不需要内核态的切换。它运行在线程之下，一个线程可能包含成百上千个goroutine 并发。每个goroutine 仅需4k～8K的内存。&lt;/p&gt;

&lt;p&gt;现在，回到主题。Go 的内存模型，同样是为了表述在什么样的条件下，一个“线程” 的 “读” 操作可以保证 “看“ 到另一个 “线程” 对同一个变量 “写” 的值的结果。这里的 ”线程“ 在Go 语言中特指的是”goroutine” 。 如果用锁（lock ）这样的方式，来显式的控制同步，保证goroutine 共享内存的严格有序，显然也是可行的。但，无论从代码书写的优雅简洁，避免代码里的逻辑混乱（加锁就要解锁），还是性能角度（所有的锁，都意味着强行的串行化）————都可以有更恰当的方式。&lt;/p&gt;

&lt;p&gt;或许是基于此，Go语言设计了Channel 和 Channel Buffer （即，限定了缓存数量的Channel ），通过Channel 通信，是Go语言中goroutine 之间同步（sychronization）的主要方式，保证了多个goroutine 对共享变量 “写” 和 “读” 的严格有序。 在 Go 语言中，这个场景下的更常见表述方式是“send” 和 “reveive” 。&lt;/p&gt;

&lt;p&gt;“Do not communicate by sharing memory; instead, share memory by communicating.” 这句“ 名言 ”，很好的概括了这一设计思想。&lt;sup id=&quot;fnref:GoComm&quot;&gt;&lt;a href=&quot;#fn:GoComm&quot; class=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;本部分小结&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;选择C++ 和Go 作为两个参照样本进行补充展开，主要从Java 的演化轨迹看，正好同时并存，并且一个代表了经典且继续老当益壮的语言；另一个代表了近10年内编程语言的一些发展趋势。&lt;/li&gt;
  &lt;li&gt;由于很多内存模型常用概念，散落在FAQ 原文的其他部分，所以会在相应的部分进行必要的展开。&lt;/li&gt;
  &lt;li&gt;原文的FAQ ，重点在并发与同步，而不是Java 运行态中的内存管理————如内存的回收等等——这是另外一个话题。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：本文在2018年初，重新进行了修订和补充&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;推荐的一些相关链接：   &lt;br /&gt;
- &lt;a href=&quot;https://tour.golang.org/concurrency/1&quot;&gt;https://tour.golang.org/concurrency/1 &lt;/a&gt; &lt;br /&gt;
- &lt;a href=&quot;https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.1.html&quot;&gt;Channel, ttps://tiancaiamao.gitbooks.io/go-internals/content/zh/07.1.html&lt;/a&gt; &lt;br /&gt;
- &lt;a href=&quot;http://pypl.github.io/PYPL.html&quot;&gt;PopularitY of Programming Language, http://pypl.github.io/PYPL.html&lt;/a&gt;   &lt;br /&gt;
- &lt;a href=&quot;http://binyanbin.github.io/2016/03/25/c-3/&quot;&gt;C语言之由内存模型说起,http://binyanbin.github.io/2016/03/25/c-3/ &lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://deferpanic.com/blog/understanding-golang-memory-usage/&quot;&gt;Understanding Go Lang Memory Usage, https://deferpanic.com/blog/understanding-golang-memory-usage/ &lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;参考索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;*&lt;end&gt;*&lt;/end&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:WikiMM&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_model_(programming)&quot;&gt;Memory Model（Progamming） &lt;/a&gt; &lt;a href=&quot;#fnref:WikiMM&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:MemPaul&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.rdrop.com/users/paulmck/scalability/paper/ordering.2007.09.19a.pdf&quot;&gt;Memory Ordering in Modern Microprocessors by Paul McKenney&lt;/a&gt; &lt;a href=&quot;#fnref:MemPaul&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:Cpp11&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx11&quot;&gt;C++11 并发（Concurrency ）相关定义  &lt;/a&gt; &lt;a href=&quot;#fnref:Cpp11&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:CppMM&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2429.htm&quot;&gt;C++11 内存模型（Memory Model） &lt;/a&gt; &lt;a href=&quot;#fnref:CppMM&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:CppAtom&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html&quot;&gt;C++ 原子化（Atomic ） &lt;/a&gt; &lt;a href=&quot;#fnref:CppAtom&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:CppTLS&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm&quot;&gt;C++ 线程本地存储（Thread Local storage ）&lt;/a&gt; &lt;a href=&quot;#fnref:CppTLS&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:CppAction&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.bogotobogo.com/cplusplus/files/CplusplusConcurrencyInAction_PracticalMultithreading.pdf&quot;&gt;C++ Concurrency in Action &lt;/a&gt; &lt;a href=&quot;#fnref:CppAction&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:Corou&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;协程 Coroutine&lt;/a&gt; &lt;a href=&quot;#fnref:Corou&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:GoComm&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.golang.org/share-memory-by-communicating&quot;&gt;Go Blog :Share Memory By Communicating &lt;/a&gt; &lt;a href=&quot;#fnref:GoComm&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Ryan Wang (Haide1977)</name><email>haide1977 AT gmail.com</email></author><category term="架构" /><category term="并发与并行" /><category term="开发语言" /><summary type="html">前言
网上有很多JSR 133 FAQ 的中文翻译版本，一大半是大家为便于自己的学习理解，做的读书笔记似的翻译。这一点上，这个版本也不例外。

不过, 本系列版本，尝试在不打破原文表达结构，更准确翻译表述的基础上，尝试对于一些关键概念，特别是随着时间推移已经有所变化的知识点，做一些拓展梳理。</summary></entry></feed>
